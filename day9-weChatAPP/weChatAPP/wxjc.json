{"title": "微信小程序开发接口之授权wx.authorize用法 ", "author": "Rolan", "pub_time": "2020-6-11 00:31", "content": [" \n                     \n                    ", "提前向用户发起授权请求。调用后会立刻弹窗询问用户是否同意授权", "小程序", "使用某项功能或获取用户的某些数据，但不会实际调用对应接口。如果用户之前已经同意授权，则不会出现弹窗，直接返回成功。", "实例代码", "// 可以通过 wx.getSetting 先查询一下用户是否授权了 \"scope.record\" 这个 scope", "wx", ".", "getSetting", "({", "  success", "(", "res", ")", " ", "{", "    ", "if", " ", "(!", "res", ".", "authSetting", "[", "'scope.record'", "])", " ", "{", "      wx", ".", "authorize", "({", "        scope", ":", " ", "'www.cnmibee.com'", ",", "        success ", "()", " ", "{", "          ", "// 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问", "          wx", ".", "startRecord", "()", "        ", "}", "      ", "})", "    ", "}", "  ", "}", "})", "// 可以通过 wx.getSetting 先查询一下用户是否授权了 \"scope.record\" 这个 scope", "wx", ".", "getSetting", "({", "  success", "(", "res", ")", " ", "{", "    ", "if", " ", "(!", "res", ".", "authSetting", "[", "'scope.record'", "])", " ", "{", "      wx", ".", "authorize", "({", "        scope", ":", " ", "'scope.record'", ",", "        success ", "()", " ", "{", "          ", "// 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问", "          wx", ".", "startRecord", "()", "        ", "}", "      ", "})", "    ", "}", "  ", "}", "})", " "]}
{"title": "Kbone原理解析与小程序技术选型 ", "author": "Rolan", "pub_time": "2020-6-29 00:15", "content": [" \n                     \n                    ", "Kbone原理解析", "官方介绍", "“Kbone 是一个致力于微信", "小程序", "和 Web 端同构的解决方案。”", "Web端框架基本原理", "首先我们来看下普通Web端框架，以Vue框架为例，一份Vue模板对应一个组件，在代码构建阶段编译成调用Dom接口的JS函数，执行此JS函数就会创建出组件对应的Dom树，从而渲染到浏览器页面上。", "然而，小程序是双线程的，并没有Dom树的概念，逻辑层和视图层完全分离，逻辑层是一个纯粹的JSCore,开发者可以编写JS脚本，但是无法直接调用Dom/Bom的api, 没有任何浏览器相关的实现。", "在小程序中，视图层和逻辑层的交互是通过数据和时间驱动的。", "因此，要实现跨端同构，问题是： ", "怎么将web端代码转为小程序代码？", "业界常规做法", "目前业界流行的第三方跨端框架们，常规做法都是：静态编译兼容。", "原理是把代码语法分析一遍，然后将其中的模板部分翻译成对应的跨端需求的模板（微信小程序、支付宝小程序、H5、APP等）。", "静态编译最大的局限性是无法保证转换的完整性，因为Vue模板和WXML模板的语法并不是直接对等的，Vue的特性设计也和小程序的设计无法划等号，这自然就导致了部分Vue特性的丢失。", "比如像Vue中的v-html指令、ref获取Dom节点、过滤器等就通通用不了。", "除了Vue自身的特性外，一些原本依赖Dom/Bom接口的Vue插件页无法使用，例如Vue-Router。", "Kbone的做法", "Kbone是通过提供 适配器 的方式来实现同构，即运行时兼容，而非静态编译。", "Kbone的适配器核心包含两个部分：", "miniprogram-render：仿造Dom/Bom接口，构造仿造Dom树；", "miniprogram-element: 监听仿造Dom树变化，渲染到页面，同时监听用户行为，触发事件。", "仿造Dom树和浏览器的运行时对比：", "仿造Dom树：", "利用内置组件和自定义组件的自引用来进行递归，创建组件树。", "如图，自定义custom-dom为递归自引用组件：", "递归的终止条件是遇到特定节点、文本节点或者children空节点。", "在创建出组件树猴，将Dom节点和自定义组件实例进行绑定，以便后续的Dom更新和操作。", "kbone这里还对节点数进行了优化：", "如果一个dom节点对应一个自定义组件的话，就会创建很多自定义组件，这样会很浪费开销，这里做了子树的合并，也就是说3层才创建一个自定义组件，节省开销。", "优化前：17个dom=17个自定义组件；优化后：17个dom=4个自定义组件，蓝色那个是单节点，会合并到上面的树；", "dom 子树作为自定义组件渲染的层级数是可以通过配置传入，理论上层级越多，使用自定义组件数量越少，性能也就越好。", "一棵很大的 Dom 树，一次性 setData 到视图层，可能会超过 setData 的大小限制（1024kB），拆分成多棵子 Dom 树，然后分批的 setData 到视图层，可以节省开销。", "事件监听", "小程序的事件是视图层到逻辑层的通讯方式，事件绑定在组件上，当被触发时，就会执行逻辑层中对应的事件处理函数。", "小程序的捕获冒泡是在视图层view端，因此逻辑层在整个捕获冒泡流程中各个节点接收到的事件不是同一个对象，小程序事件的捕获冒泡和阻止冒泡等操作必须在WXML模板中生命，无法使用接口实现。 ", "为了能够让web端和小程序端的事件系统行为一致，kbone除了仿造了一份Dom树外，也把整个事件系统仿造了一份，即在仿造Dom树上进行捕获冒泡。", "当自定义组件监听到用户的操作后，就将事件发往仿造Dom树，后续自定义组件监听到的同一个事件的冒泡就直接忽略。", "当触发改节点，仿造Dom树接收到事件后，再进行捕获和冒泡，让事件在各个节点触发。", "Kbone的优势", "支持多个前端框架：Vue、React、Preact 等", "支持更为完整的前端框架特性：Vue 中的 v-html 指令、Vue-router 插件等", "提供了常用的 dom/bom 接口", "可以使用小程序本身的特性：live-player 内置组件、分包功能等", "提供一些 Dom 扩展接口：getComputedStyle 接口等", "Kbone实践", "脚手架kbone-cli", "官方已经提供了kbone-cli可以用来快速开发：", "用npm全局安装kbone-cli", "可以根据自己的技术栈选择不同的开发模板：React/Vue/Omi/Preact", "然后就可以愉快的进行开发啦~", "生成的demo项目结构如下： ", "demo中包含了多页跳转、vue-router、vuex等的使用示例，以及mp-webpack-plugin的配置示例。", "对于多页面的应用，在 Web 端可以直接通过 a 标签或者 location 对象进行跳转，但是在小程序中则行不通。同时 Web 端的页面 url 实现和小程序页面路由也是完全不一样的。", "Demo示例对比", " 其中，有一部分两端差异的业务逻辑功能，也给出了3中不同的解决方案：", "利用vue-improve-loader，在构建时对dom树节点进行删减，在需要提出的节点加上check-reduce属性 利用reduce-loader，将业务中不需要被打包的代码进行去除，使用行内loader和环境变量来判断 使用样式隐藏，即设置不需要显示的节点样式为 display:none", "其他问题", "在实际开发中，还会碰到一些细节，例如：", "多页面开发：修改webpack和mp-webpack-plugin配置", "小程序内置组件：部分用html标签代替，其他用wx-component + behavior标签", "小程序自定义组件：修改mp-webpack-plugin配置，补充wxCustomComponents字段，将自定义组件放入组件根目录，使用自定义组件", "自定义app.js和app.wxss：监听app的生命周期，修改webpack配置补充app.js的构建入口，修改插件配置的generate.app字段，补充app.js", "扩展dom/bom对象和API：使用 window.$$extend追加方法", "代码优化：用reduce-loader做体积精简，dom树精简用vue-improve-loader", "区分环境实现不同功能：process.env.isMiniprogram", "更新迭代", "kbone由于目前在快速发展期，更新迭代非常迅速，以下特性是对比了8月份的版本和11月份版本，可以看出已经解决了近2/3的问题。", "小程序技术选型", "详细了解了kbone之后，我们来分析下小程序技术框架到底应该怎么选？", "kbone & 小程序原生", "已有web版，需要小程序版：kbone", "跨平台需求（web + 小程序）：kbone", "对性能特别苛刻 or 追求稳定 or 要用最新功能：小程序原生", "页面节点数量特别多（ 1000 节点以上），且对渲染性能要求高：静态模板转义方案（第三方框架：mpvue/taro等）", "第三方框架", "MpVue ：不推荐再用了，坑越来越多，内部也表示之后不会投入太多维护", "WePY 1.7.x ：不推荐再用了：1.7.x 的版本在最初的设计上的缺陷导致遗留了很多比较严重的问题", "WePY 2.0：现在还是 alpha 阶段，内外部有一些小程序在跑，体验和反馈还可以。但依然 issue 比较多。害怕踩坑的也不推荐使用", "Taro: 也还是有不少问题，但相对来说应该是比 mpVue 和 WePY 更稳定一点", "Uni-app：mpvue的衍生版，跨端 (官方示例有6端) 支持的很好，在H5端实现了一套微信模拟器，可以尝试，是目前唯一支持app端的商用方案，有独立的编辑器HBuildX", "Chameleon: 统一的多态协议，渐进式跨端，提供脚手架命令工具，规划比较宏大", "Omi ：基于Taro完成的框架，kbone有支持omi的模板", "Nanachi: 基于react的编译期间的转义框架", "总结", "没有跨端需求，只需要微信小程序 ==> 小程序原生", "web端转小程序 or 两端 or 想要尝鲜 ==> kbone", "多端 or Vue 技术栈 ==> uni-app", "多端 or React 技术栈 ==> taro", "不介意学习新技术栈 ==> wepy 2.0 or chaemeleon", "写在最后", "小程序在非常快速的更新迭代，就算是原生框架也还是有一些坑的，因此没有哪种框架是百分之百完美，需要根据业务具体需求以及自身技术栈偏好来进行选择。", " "]}
{"title": "微信小程序+Java后台开发(详细解释，附代码) ", "author": "Rolan", "pub_time": "2020-6-29 00:33", "content": [" \n                     \n                    ", "微信", "小程序", "+Java后台开发", "\r\n", "全部代码链接", "\r\n", "链接：", "pan.baidu.com/s/1viujpT2E…", "\r\n提取码：wcvd", "\r\n", "\r\n", "通过这个博客，你可以快速的搭建一个微信小程序前端和后台相连的一个功能，在这里我会详细的解说每一个步骤，就是如何实现小程序的前后台相互关联；因为是实现简易的小程序的某个功能，主要是为了了解小程序前台如何和后台相连，所以在此博客中使用的是本地tomcat服务器。", "\r\n", "\r\n", "使用的工具：", "\r\n", "idea", "\r\nspringmvc", "\r\n微信小程序开发工具\r\ntomcat", "\r\n", "微信小程序API", "\r\n**所使用的jar包  **", "\r\n我已经上传到百度云盘里了，如果有需要可以去下载\r\n链接：", "pan.baidu.com/s/1KSqQLs9J…", "\r\n提取码：9s0s\r\n", "\r\n1.JAV后端详解", "\r\n", "我写后台主要使用的是Java，框架是SSM，由于自己的知识浅薄，只能使用自己已有的知识进行开发学习，因为微信小程序前台和后台数据传输是以Json数据格式传送的，所以建议如果了解过springBoot的话，用它更加方便快捷。", "\r\n", "在这里我给大家说一个json数据格式究竟是什么，希望对大家有点帮助！！！", "\r\n", "\r\n", "json数据格式", "\r\njson有两种格式：一个是json对象，另一种是json数组", "\r\n2.1    json对象：可以理解为Java中对象，是以键值对形式存在的", "\r\n例子：  {\"key\":value, \"key1\":value1}", "\r\n2.1.2    json数组：", "\r\n例子：[{\"key\":value,\"key\":value}]", "\r\n", "\r\n", "首先在idea中创建一个JavaEE项目，具体如何创建，在这里我就不祥解了，如果有不会的，可以去网上搜一艘，在这里我会直接打开我先前创建下个JavaEE项目。", "\r\n", "\r\n", "首先在微信小程序开发工具中新建一个项目，然后再自己所写的某一个页面中，其次在自己页面的wxml文件中编写内容\r\nweb.xml", "\r\n", "\r\n", "<?xml version=", "\"1.0\"", " encoding=", "\"UTF-8\"", "?>\r\n<web-app xmlns=", "\"http://xmlns.jcp.org/xml/ns/javaee\"", "\r\n         xmlns:xsi=", "\"http://www.w3.org/2001/XMLSchema-instance\"", "\r\n         xsi:schemaLocation=", "\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"", "\r\n         version=", "\"4.0\"", ">\r\n\r\n    <!--前端控制器-->\r\n    <servlet>\r\n        <servlet-name>springmvc</servlet-name>\r\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n        <init-param>\r\n            <param-name>contextConfigLocation</param-name>\r\n            <param-value>classpath:springmvc.xml</param-value>\r\n        </init-param>\r\n        <load-on-startup>1</load-on-startup>\r\n    </servlet>\r\n    <servlet-mapping>\r\n        <servlet-name>springmvc</servlet-name>\r\n        <url-pattern>/</url-pattern>\r\n    </servlet-mapping>\r\n    <!--字符编码-->\r\n    <filter>\r\n        <filter-name>encoding</filter-name>\r\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n        <init-param>\r\n            <param-name>encoding</param-name>\r\n            <param-value>utf-8</param-value>\r\n        </init-param>\r\n    </filter>\r\n    <filter-mapping>\r\n        <filter-name>encoding</filter-name>\r\n        <url-pattern>/*</url-pattern>\r\n    </filter-mapping>\r\n</web-app>\r\n", "复制代码", "\r\n", "其次在src/springmvc.xml编写springMVC的配置文件\r\nspringMVC.xml", "\r\n", "\r\n", "<?xml version=", "\"1.0\"", " encoding=", "\"UTF-8\"", "?>\r\n<beans xmlns=", "\"http://www.springframework.org/schema/beans\"", "\r\n       xmlns:xsi=", "\"http://www.w3.org/2001/XMLSchema-instance\"", "\r\n       xmlns:mvc=", "\"http://www.springframework.org/schema/mvc\"", "\r\n       xmlns:context=", "\"http://www.springframework.org/schema/context\"", "\r\n       xsi:schemaLocation=", "\"http://www.springframework.org/schema/beans\r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/mvc\r\n        http://www.springframework.org/schema/mvc/spring-mvc.xsd\r\n         http://www.springframework.org/schema/context\r\n        http://www.springframework.org/schema/context/spring-context.xsd\"", "\r\n       default-autowire=", "\"byName\"", ">\r\n\r\n    <!--注解扫描-->\r\n    <context:component-scan base-package=", "\"com.zb.lq.controller\"", "/>\r\n    <!--注解驱动-->\r\n    <mvc:annotation-driven></mvc:annotation-driven>\r\n</beans>\r\n", "复制代码", "\r\n", "然后在控制器中编写代码\r\n", "我的实在DemoController中编写的", "\r\n", "\r\nDemoController.java", "\r\n", "\r\n", "@Controller\r\npublic class DemoController {\r\n    @RequestMapping(", "\"getUser\"", ")\r\n    @ResponseBody\r\n    public List<String> ", "getUser", "(){\r\n        List<String> list = new ArrayList<>();\r\n        list.add(", "\"中北大学\"", ");\r\n        list.add(", "\"653\"", ");\r\n        list.add(", "\"实验室\"", ");\r\n        ", "return", " list;\r\n    }\r\n}\r\n", "复制代码", "至此，使用Java编写的后台已经基本完成，接下来启动tomcat，测试看是否编写成功\r\n如果出现一下内容，则说明后台编写成功，要以json格式输出，因为小程序前台和后台相连是以json格式输出的", "\r\n", "\r\n", "\r\n", "我以简单的按钮实现前后台交互：\r\nindex.wxml", "\r\n", "\r\n", "<button bindtap=", "'houduanRequest'", ">获取信息</button>\r\n<view wx:", "for", "=", "\"{{list}}\"", " wx:fot-item=", "\"item\"", ">\r\n  姓名：{{item}}\r\n</view>\r\n", "复制代码", "index.js", "\r\n", "//index.js\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    list:", "''", "\r\n  },\r\n  houduanRequest:", "function", "(){\r\n    var that = this;\r\n    wx.request({\r\n      url: ", "'http://localhost:8888/xiaochengxu/getUser'", ",//自己请求的服务器的地址\r\n      method: ", "'GET'", ",\r\n      header: {\r\n        ", "'content-type'", ": ", "'application/json'", " // 默认值\r\n      },\r\n      success: ", "function", " (req) {\r\n        var list = req.data;\r\n        ", "if", " (list == null) {\r\n          wx.showToast({\r\n            title: ", "'ErrorMessage'", ",\r\n            icon: ", "'false'", ",   //图标\r\n            duration: 1500  //提示的延迟的时间\r\n          })\r\n        } ", "else", " {\r\n          that.setData({\r\n            list: list\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n\r\n  onLoad: ", "function", "() {\r\n    \r\n  }, \r\n\r\n})\r\n\r\n", "复制代码", "到此基本的功能代码已经完成了，现在我们开始启动tomcat，进行运行，看看结果究竟是什么...", "\r\n", "\r\n", "到此，实现小程序前后台相连已经实现了\r\n希望对大家有点帮助！！！", " "]}
{"title": "微信小程序实现上传多张图片、删除图片 ", "author": "Rolan", "pub_time": "2020-6-29 00:40", "content": [" \n                     \n                    ", "最近在做微信", "小程序", "，遇到上传多张图片到服务器，计算上传图片的张数，并且可以手动删除图片，下面是效果图", "效果图：", "本来用的是小程序提供的 ", "mp-uploader ", "上传图片的组件，无奈次组件删除效果不是我想要的，只能用 wx.chooseImage进行上传图片，在使用uplaodFile将图片发送给后台服务器。", "下面直接展示代码：", "wxml:", "<view class=\"con_titles\">\r\n <view class=\"con_left\">\r\n  <image src=\"../../images/comint.png\"></image>\r\n  <text class=\"titles_t\">患者病历</text>\r\n </view>\r\n <view class=\"img_num\">{{imgShow.length}}/6</view>\r\n\r\n </view>\r\n <view class=\"page__bd\">\r\n <!-- <mp-uploader style='color:#353535' bindfail=\"uploadError\" bindsuccess=\"uploadSuccess\" select=\"{{selectFile}}\" upload=\"{{uplaodFile}}\" files=\"{{files}}\" max-count=\"6\" title=\"患者病历\"></mp-uploader> -->\r\n\r\n <view class=\"add-image\">\r\n  <view class=\"images-boxc\" wx:for=\"{{imgShow}}\" wx:for-item=\"item\" wx:key=\"image\">\r\n  <image class=\"image_size\" data-index=\"{{index}}\" data-src=\"{{item}}\" src=\"{{item}}\" bindtap=\"clickImage\"></image>\r\n  <image class=\"delete-image\" data-index=\"{{index}}\" src=\"../../images/delete_img.png\" bindtap=\"deleteImage\"></image>\r\n  </view>\r\n  <view class=\"images-add\" wx:if=\"{{imgShow.length<6}}\">\r\n  <image class=\"image_size image_sizen\" src=\"../../images/add_img.png\" bindtap=\"chooseImage\"></image>\r\n  </view>\r\n </view>\r\n</view>", "wxss:", "/* 上传图片 */\r\n.images-boxc {\r\n position: relative;\r\n border: dashed 1px #bfbfbf;\r\n width: 139rpx;\r\n height: 139rpx;\r\n margin-right: 32rpx;\r\n margin-bottom: 32rpx;\r\n}\r\n.delete-image {\r\n position: absolute;\r\n width: 30rpx;\r\n height: 30rpx;\r\n right: 16rpx;\r\n top: 16rpx;\r\n}\r\n.add-image {\r\n display: flex;\r\n flex-wrap: wrap;\r\n}\r\n.image_size {\r\n width: 139rpx;\r\n height: 139rpx;\r\n}\r\n.image_sizen {\r\n height: 142rpx;\r\n}", "js:", "data: {\r\n count: 6, //设置最多6张图片\r\n\r\n allImg: [],\r\n imgShow: [],\r\n\r\n },\r\n// 上传图片\r\n chooseImage: function() {\r\n wx.showLoading({\r\n  title: '加载中...',\r\n  mask: true\r\n })\r\n var that = this;\r\n var imgShow = that.data.imgShow;\r\n var count = that.data.count - imgShow.length; //设置最多6张图片\r\n wx.chooseImage({\r\n  count: count,\r\n  sizeType: ['compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n  sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n  success: function(res) {\r\n  console.log(res)\r\n  that.uplaodFile(res)\r\n  for (var i = 0, h = res.tempFilePaths.length; i < h; i++) {\r\n   imgShow.push(res.tempFilePaths[i]);\r\n   that.setData({\r\n   imgShow: imgShow\r\n   })\r\n  }\r\n  wx.hideLoading({\r\n   title: '加载中...',\r\n   mask: false\r\n  })\r\n\r\n  }\r\n })\r\n },\r\n // 删除图片\r\n deleteImage(e) {\r\n let self = this;\r\n let index = e.target.dataset.index;\r\n let imgShow = self.data.imgShow;\r\n let allImg = self.data.allImg;\r\n allImg.splice(index, 1);\r\n imgShow.splice(index, 1);\r\n this.setData({\r\n  imgShow: imgShow,\r\n  allImg: allImg\r\n })\r\n },\r\n previewImage: function(e) {\r\n console.log(this.data.files)\r\n wx.previewImage({\r\n  current: e.currentTarget.id, // 当前显示图片的http链接\r\n  urls: this.data.files // 需要预览的图片http链接列表\r\n })\r\n },\r\n selectFile(files) {\r\n console.log('files', files)\r\n // 返回false可以阻止某次文件上传\r\n },\r\n uplaodFile(files) {\r\n console.log('upload files', files)\r\n let that = this\r\n files.tempFilePaths.forEach(element => {\r\n  util.uploadFile('/fastdfsServer/fileUpload', element, 'file', {}, function(res) { //上传本地图片地址到服务器 返回地址 存放到input提交时取值\r\n  res = JSON.parse(res);\r\n  if (res.responseCode == 0) {\r\n   sysMsg.sysMsg(\"上传成功\", 1000, 'success');\r\n   that.setData({\r\n   allImg: that.data.allImg.concat(res.responseBody)\r\n   });\r\n  } else {\r\n   sysMsg.sysMsg(\"上传失败\", 1500, 'error');\r\n  }\r\n  });\r\n\r\n });\r\n // 文件上传的函数，返回一个promise\r\n return new Promise((resolve, reject) => {\r\n  resolve({\r\n  urls: files.tempFilePaths\r\n  });\r\n  setTimeout(() => {\r\n  reject('some error')\r\n  }, 10000)\r\n\r\n })\r\n\r\n },\r\n uploadError(e) {\r\n console.log('upload error', e.detail)\r\n },\r\n uploadSuccess(e) {\r\n // this.setData({\r\n // allImg: this.data.allImg.concat(e.detail.urls[0])\r\n // });\r\n console.log('upload success', e.detail, e.detail.urls)\r\n\r\n},", "以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持我们。", " "]}
{"title": "微信小程序实现图片上传放大预览删除代码 ", "author": "Rolan", "pub_time": "2020-6-29 00:52", "content": [" \n                     \n                    ", "本文实例为大家分享了微信", "小程序", "图片上传放大预览的具体代码，供大家参考，具体内容如下", "效果：", "image.js代码：", "Page({\r\n //选择相册或拍照\r\n data: {\r\n  imgs: []\r\n },\r\n//上传图片\r\n chooseImg: function (e) {\r\n  var that = this;\r\n  var imgs = this.data.imgs;\r\n  if (imgs.length >= 9) {\r\n   this.setData({\r\n    lenMore: 1\r\n   });\r\n   setTimeout(function () {\r\n    that.setData({\r\n     lenMore: 0\r\n    });\r\n   }, 2500);\r\n   return false;\r\n  }\r\n  wx.chooseImage({\r\n   // count: 1, // 默认9\r\n   sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n   sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n   success: function (res) {\r\n    // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n    var tempFilePaths = res.tempFilePaths;\r\n    var imgs = that.data.imgs;\r\n    // console.log(tempFilePaths + '----');\r\n    for (var i = 0; i < tempFilePaths.length; i++) {\r\n     if (imgs.length >= 9) {\r\n      that.setData({\r\n       imgs: imgs\r\n      });\r\n      return false;\r\n     } else {\r\n      imgs.push(tempFilePaths[i]);\r\n     }\r\n    }\r\n    // console.log(imgs);\r\n    that.setData({\r\n     imgs: imgs\r\n    });\r\n   }\r\n  });\r\n },\r\n // 删除图片\r\n deleteImg: function (e) {\r\n  var that = this;\r\n  var imgs = that.data.imgs;\r\n  var index = e.currentTarget.dataset.index;//获取当前长按图片下标\r\n  wx.showModal({\r\n   title: '提示',\r\n   content: '确定要删除此图片吗？',\r\n   success: function (res) {\r\n    if (res.confirm) {\r\n     console.log('点击确定了');\r\n     imgs.splice(index, 1);\r\n    } else if (res.cancel) {\r\n     console.log('点击取消了');\r\n     return false;\r\n    }\r\n    that.setData({\r\n     imgs: imgs\r\n    });\r\n   }\r\n  })\r\n },\r\n  // 预览图片\r\n  previewImg: function (e) {\r\n   //获取当前图片的下标\r\n   var index = e.currentTarget.dataset.index;\r\n   //所有图片\r\n   var imgs = this.data.imgs;\r\n\r\n   wx.previewImage({\r\n    //当前显示图片\r\n    current: imgs[index],\r\n    //所有图片\r\n    urls: imgs\r\n   })\r\n  }\r\n})", "image.wxml代码：", "<button class=\"upload-img-btn\" bindtap=\"chooseImg\">上传</button>\r\n <view class=\"img\" wx:for=\"{{imgs}}\" wx:for-item=\"item\" wx:key=\"*this\">\r\n  <image src=\"{{item}}\" data-index=\"{{index}}\" mode=\"widthFix\" bindtap=\"previewImg\" bindlongpress=\"deleteImg\"></image>\r\n </view>", "保存到服务器上的代码未完待续。", "以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持我们。", " "]}
{"title": "多图上传（兼容微信小程序只能单图上传） - 开发uniapp项目，遇到的问题（主H5，微信 ... ", "author": "Rolan", "pub_time": "2020-6-30 00:22", "content": [" \n                     \n                    ", "Demo：", "uni-app template GitHub Address", "问题", "需求中，需要上传多张图片，但是微信", "小程序", "只能单图上传，多图上传只支持App、H5。", "如果只能一张一张上传图片的话，用户体验相当差，我相信上传的用户，会疯的……", "思路", "对此官方文档也给出了解决方案，就是重复调用api uni.uploadFile", "解决方法", "我使用了uni-app插件市场中luck-request插件（仿axios封装request网络请求库，支持拦截器以及task操作），对于uni.uploadFile，也有封装。", "在此，我在api.js的文件中又定义封装了上传图片的方法。", "// 上传图片，接口名称根据自己后端定义，此接口调用不通", "export const uploadToOss = (params) => axios.upload('/api/upload/xxx', {", "    ...params,", "    custom: {", "        loading: true,", "        loadingTitle: '正在上传...'", "    }", "})", "UploadPic.vue", "<template>", "    <view class=\"upload_box\">", "        <view class=\"image_list\">", "            <view class=\"image_item\" v-for=\"(item, index) in files\" :key=\"index\">", "                <view class=\"icon iconfont iconshanchu\" @click=\"removeItem(index)\"></view>", "                <image :src=\"item\"></image>", "            </view>", "            <view class=\"upload\" v-if=\"files.length < limit\" @click=\"handleUpload\">", "                <view class=\"icon iconfont iconshangchuan\"></view>", "                <text>{{ btnText }}</text>", "            </view>", "        </view>", "        <view class=\"upload_tip\" v-if=\"tip\">{{ tip }}</view>", "    </view>", "</template>", "<script>", "import { uploadToOss } from '@/api/http';", "export default {", "    props: {", "        // 提示信息", "        tip: {", "            type: String,", "            default: ''", "        },", "        // 按钮文字", "        btnText: {", "            type: String,", "            default: ''", "        },", "        // 最多限制张数，默认1张", "        limit: {", "            type: Number,", "            default: 1", "        },", "        // 图片类型，用于同个页面多个图片上传组件区分", "        imgType: {", "            type: String,", "            default: 'image'", "        }", "    },", "    data() {", "        return {", "            files: [] // 上传图片后的图片地址集合", "        };", "    },", "    methods: {", "        /**", "         * @description 删除图片", "         * @param {Number} index 图片所在索引值", "         */", "        removeItem(index) {", "            this.files.splice(index, 1);", "            this.sendMessage(); // 发送信息父组件", "        },", "        /**", "         * @description 上传图片", "         * @param {String} url 图片临时地址", "         */", "        uploadImg(url) {", "            return new Promise((resolve, reject) => {", "                uploadToOss({", "                    filePath: url,", "                    fileType: 'image',", "                    name: 'file',", "                }).then(res => {", "                    if(res._OK) {", "                        resolve(res.data.data);", "                    } else {", "                        uni.showModal({", "                            title: '提示',", "                            content: res.data.message || '上传失败'", "                        })", "                        ", "                        return new Promise.reject(res);", "                    }", "                }).catch(err => {", "                    return new Promise.reject(err);", "                })", "            })", "        },", "        ", "        /**", "         * @description 遍历调用upload接口", "         * @param {Array} tempFilePaths uni.chooseImage选择图片后返回的临时图片地址集合", "         * @returns {Array} arr 异步调用upload接口返回的图片服务器上的地址集合", "         */", "        async uploads(tempFilePaths) {", "            let arr = [];", "            for(let i = 0; i < tempFilePaths.length; i++) {", "                arr[i] = await this.uploadImg(tempFilePaths[i]);", "            }", "            ", "            return arr;", "        },", "        ", "        /**", "         * @description 上传图片", "         */", "        handleUpload() {", "            let _this = this;", "            ", "            uni.chooseImage({", "                count: _this.limit,", "                async success(chooseImageRes) {", "                    // 选择图片后，立即调用图片上传的接口，es6的await必须被async包含。", "                    let files = await _this.uploads(chooseImageRes.tempFilePaths);", "                    _this.files = [..._this.files, ...files];", "                    _this.sendMessage(); // 发送信息父组件", "                }", "            });", "        },", "        /**", "         * @description 发送信息给父组件", "         */", "        sendMessage() {", "            this.$emit('on-change', {", "                files: this.files,", "                imgType: this.imgType", "            });", "        }", "    }", "};", "</script>", "<style lang=\"scss\" scoped>", ".upload_box {", "    .upload {", "        width: 120rpx;", "        height: 120rpx;", "        border: 2rpx solid #d9d9d9;", "        font-size: 24rpx;", "        color: #999999;", "        display: flex;", "        justify-content: center;", "        flex-direction: column;", "        align-items: center;", "        margin-bottom: 20rpx;", "        .iconfont {", "            margin-bottom: 8rpx;", "        }", "    }", "    .image_list {", "        display: flex;", "        flex-wrap: wrap;", "        .image_item {", "            position: relative;", "            width: 120rpx;", "            height: 120rpx;", "            margin: 0 20rpx 20rpx 0;", "            z-index: 1;", "            image {", "                width: 120rpx;", "                height: 120rpx;", "            }", "            .iconfont {", "                color: #ff0000;", "                font-size: 30rpx;", "                position: absolute;", "                z-index: 10;", "                right: 0;", "                top: 0;", "            }", "        }", "    }", "}", ".upload_tip {", "    color: #999999;", "    font-size: 24rpx;", "    margin-top: -10rpx;", "}", "</style>", "总结", "该多图上传组件的交互跟拓展性还不够好，但基本满足了目前产品的需求，之后还是会持续迭代更新的，也希望大家多多提意见。", " "]}
{"title": "最新反编译任何微信小程序，以及独立分包、插件的处理方式 ... ", "author": "Rolan", "pub_time": "2020-6-30 00:49", "content": [" \n                     \n                    ", "本篇文章将详细讲解如何对线上的微信", "小程序", "进行解包反编译，并处理独立分包加载、插件等情况下的解决方法，最终获得他的源码以用来学习，没错，就是学习。:smile:本教程也仅用于学习。 所谓工欲善其事，必先利其器，我们先来准备一下需要准备的东西：", "一台具有ROOT权限的手机。（可以使用Android模拟器） Node.js环境 反编译的脚本： ", "github.com/141Mr-liu/w…", " （我们这里使用了支持分包加载的，当然普通的也能用）", "获取需要反编译小程序的包", "首先，要想反编译获得微信小程序源码，那我们必须先有这个微信小程序的一个包，那我们应该怎么去获取这个包呢？我们需要一台具有ROOT权限的手机，但在9012年了，ROOT的手机应该很少了吧，那么我们可以通过Android模拟器来实现这一步。这里我推荐夜神模拟器，因为他对权限、文件的的管理会比较方便。", "我们先打开模拟器或手机，因为手机自带的浏览器看不到一些隐藏的目录，所以我们下载RE浏览器，这也是要求ROOT权限的原因。打开RE浏览器，确认权限正常，进入 /data/data/com.tencent.mm/MicroMsg/appbrand 下，你会看到一个类似 ", "a8b3488516c9d81e1d5f511891583cf9", " 的文件夹，这个是以用户来分类的，如果有多个，可以全删掉，进入 ", "a8b3488516c9d81e1d5f511891583cf9", " 文件夹下，进入pkg文件夹下，这个文件夹就是用来防止微信小程序包的，后缀为**.wxapkg**的就是小程序的包，建议除了最大的那个（大概7-8M左右）包，其他的全部删掉，方便后续找到我们所需要的包。", "准备工作完成后，我们打开微信，打开想要反编译的小程序，这是pkg目录下会出现一个新的wxapkg包，将这个包复制到电脑上。夜深模拟器的话可以通过共享文件夹实现。", "反编译前准备", "安装node.js（傻瓜式安装，不做讲解）", "使用CMD命令行进入到我们所下载的反编译脚本目录，依次输出一下指令安装依赖：", "npm ", "install", " esprima\r\nnpm ", "install", " css-tree\r\nnpm ", "install", " cssbeautify\r\nnpm ", "install", " vm2\r\nnpm ", "install", " uglify-es\r\nnpm ", "install", " js-beautify\r\n复制代码", "安装完成后我们就可以正式开始反编译我们的微信小程序了", "建议将小程序的包放在比较好操作的位置，例如磁盘更目录或脚本的目录，方便后续操作", "CMD进入脚本目录，使用指令 ", "node wuWxapkg.js C:\\1.wxapkg", " 对小程序包进行解包，其中，C:\\1.wxapkg为所需要解包的小程序。", "如果不出任何BUG的话在包的目录下会出现一个包名的文件夹，这个文件夹就是最终反编译的源码了。", "如果小程序中有独立分包，那我们应该进行一下操作：", "1. ", "获得要解包的主包和子包\r\n", "2. ", "解包主包 bingo.sh testpkg/master-xxx.wxapkg\r\n", "3. ", "解包子包 bingo.sh testpkg/sub-1-xxx.wxapkg -s=../master-xxx 其中，sub-1-xxx.wxapkg为子包wxapkg，-s=后面为子包在主包中的路径\r\n复制代码", "当然，也可以直接解包主包和子包，然后把主包中子包的文件替换掉就行了。", "常见问题解决", "BUG1 # $gwx is not defined", "使用编辑器打开 wuWxss.js 文件，找到 runVM 函数，将函数内容替换成：", "let", " wxAppCode = {};\r\n      ", "let", " handle = {cssFile: name};\r\n      ", "let", " gg = new GwxCfg();\r\n      ", "let", " tsandbox = {\r\n         $gwx: GwxCfg.prototype[", "\"$gwx\"", "],\r\n         __mainPageFrameReady_", "_", ": GwxCfg.prototype[", "\"$gwx\"", "],   //解决 $gwx is not defined\r\n         __vd_version_info_", "_", ": GwxCfg.prototype[", "\"$gwx\"", "],  //解决 __vd_version_info_", "_", " is not defined\r\n         __wxAppCode_", "_", ": wxAppCode,\r\n         setCssToHead: cssRebuild.bind(handle)\r\n      }\r\n \r\n      ", "let", " vm = new VM({sandbox: tsandbox});\r\n      vm.run(code);\r\n      ", "for", " (", "let", " name ", "in", " wxAppCode) {\r\n         if (name.endsWith(", "\".wxss\"", ")) {\r\n            handle.cssFile = path.resolve(frameName, ", "\"..\"", ", name);\r\n            wxAppCode[name]();\r\n         }\r\n      }\r\n复制代码", "重新编译一下就好了。", "BUG2: no such file or directory, open '...\\plugin:\\wxa75efa648b60994b....json' ，也就是插件报错。", "这个问题是你找遍全网，也不会有人告诉你的，反正我解决的时候，是baidu、google都找遍了，也没找到解决方法，网上全是一些复制站贴的基本内容…… 其实这个问题很好解决，首先我们看报错信息， no such file or directory, open '...\\plugin:\\wxa75efa648b60994b....json' ，你品，你细品，话说**\\plugin:**这个目录是啥，也就是这个目录的原因，造成了博主在百度和谷歌上找了半天的答案，最后还是靠自己解决了。 在Windows系统中，并支持以 : 命名的文件夹，所以对应的plugin文件夹被系统重命名成了“plugin”，所以程序找不到这个文件夹，惊不惊喜，意不意外，解决方式也很简单。解决的方式有两种：", "修改脚本中内容，将plugin: 修改成其他格式。( ", "这方式无效", " ，不能通过脚本修改了，那个plugin：其实是微信那个wxapkg里面的东西，如果小程序引用了第三方插件的话，就会有这个文件夹)", "将文件和脚本放到Linux上执行，因为Linux就没这么多屁事。", " "]}
{"title": "支付宝小程序实现省市区三级联动 ", "author": "Rolan", "pub_time": "2020-6-23 00:44", "content": [" \n                     \n                    ", "本文实例为大家分享了支付宝", "小程序", "实现省市区三级联动的具体代码，供大家参考，具体内容如下", "背景", "最近做的项目 有省市区联动。不仅要传name还要把对应的id发给后台。", "支付宝提供的级联有 ", "my.multiLevelSelect", " 和 ", "picker", " 并不能满足需求。", "picker 组件不支持多列选择，所以使用 ", "picker-view", " 组件和 ", "Popup", " 配合使用。", "实现效果图", "数据结构", "citys - 城市 areas - 区", "当然这是处理之后的，行政区划树 不长这样子。", "[{\r\n", " code:", "1", ",\r\n", " name:", "'北京'", ",\r\n", " areas:", "[\r\n  {\r\n", "  code:", " ", "101", ",\r\n", "  name:", "'朝阳区'", "\r\n  },\r\n  {\r\n", "  code:", " ", "101", ",\r\n", "  name:", "'丰台区'", "\r\n  }\r\n ]\r\n },{\r\n", " code:", "2", ",\r\n", " name:", "'河北省'", ",\r\n", " citys:", "[\r\n  {\r\n", "  code:", " ", "20", ",\r\n", "  name:", "'石家庄市'", ",\r\n", "  areas:", "[{\r\n", "   code:", "'201'", ",\r\n", "   name:", "'长安区'", "\r\n  }]\r\n  }\r\n ]\r\n }]", "详细实现 仅供参考", "//ahtml\r\n", "<", "popup", " ", "show", "=", "\"", "{{showBottom}", "}\"", " ", "position", "=", "\"bottom\"", " ", "onClose", "=", "\"onPopupClose\"", " ", "className", "=", "\"cityPop\"", ">", "\r\n ", "<", "view", " ", "class", "=", "\"flex\"", ">", "\r\n ", "<", "view", " ", "onTap", "=", "\"onPopupClose\"", ">", "取消", "</", "view", ">", "\r\n ", "<", "view", " ", "onTap", "=", "\"bindMultiPickerChange\"", " ", "class", "=", "\"confrim\"", ">", "确定", "</", "view", ">", "\r\n ", "</", "view", ">", "\r\n ", "<", "view", ">", "\r\n  ", "<", "picker-view", " ", "value", "=", "\"", "{{multiIndex}", "}\"", " ", "onChange", "=", "\"bindMultiPickerColumnChange\"", " ", "class", "=", "\"mypicker\"", ">", "\r\n  ", "<", "block", " ", "a:for", "=", "\"", "{{multiArray}", "}\"", ">", "\r\n   ", "<", "picker-view-column", " ", "key", "=", "\"", "{{index}", "}\"", ">", "\r\n   ", "<", "block", " ", "a:for", "=", "\"", "{{item}", "}\"", " ", "a:for-item", "=", "\"colItem\"", ">", "\r\n    ", "<", "view", " ", "key", "=", "\"", "{{colItem.code}", "}\"", ">", "{{colItem.name}", "}", "</", "view", ">", "\r\n   ", "</", "block", ">", "\r\n   ", "</", "picker-view-column", ">", "\r\n  ", "</", "block", ">", "\r\n ", "</", "view", ">", "\r\n ", "</", "popup", ">", "// 滚动选择", "\r\nbindMultiPickerColumnChange(e) {\r\n ", "// 注意处理直辖市自治区（nodeType =2 -- citys(null) areas(Array)）与其他省份(nodeType=1 -- citys(Array) areas(Array))", "\r\n let newColums = e.detail.value;\r\n let {\r\n  multiIndex\r\n } = ", "this", ".", "data", ";\r\n let newMultiIndex=[]\r\n ", "if", "(multiIndex[", "0", "]!=newColums[", "0", "]) {\r\n  newMultiIndex=[newColums[", "0", "], ", "0", ", ", "0", "]\r\n  }", "else", " {\r\n  newMultiIndex=[multiIndex[", "0", "], newColums[", "1", "],newColums[", "2", "]|| ", "0", "]\r\n  };\r\n console.log(", "'修改的列为'", ", newMultiIndex);\r\n ", "var", " ", "data", " = {\r\n  multiArray: ", "this", ".", "data", ".multiArray,\r\n  multiIndex: newMultiIndex\r\n };\r\n ", "var", " ", "data", ".multiArray[", "0", "] = ", "this", ".", "data", ".provinces;\r\n ", "if", " ((temp[", "data", ".multiIndex[", "0", "]].citys) && (temp[", "data", ".multiIndex[", "0", "]].citys).length > ", "0", ") {\r\n  ", "//如果第二列“市”的个数大于0,通过multiIndex变更multiArray[1]的值", "\r\n  ", "data", ".multiArray[", "1", "] = temp[", "data", ".multiIndex[", "0", "]].citys || [];\r\n  ", "var", " areaArr = (temp[", "data", ".multiIndex[", "0", "]].citys[", "data", ".multiIndex[", "1", "]]) && (temp[", "data", ".multiIndex[", "0", "]].citys[", "data", ".multiIndex[", "1", "]]).areas || [];\r\n  ", "//如果第三列“区”的个数大于0,通过multiIndex变更multiArray[2]的值；否则赋值为空数组", "\r\n  ", "data", ".multiArray[", "2", "] = areaArr.length > ", "0", " ? areaArr : [];\r\n } ", "else", " {\r\n  ", "//如果第二列“市”的个数不大于0，那么第二列“市”和第三列“区”都赋值为空数组", "\r\n  ", "//直辖市citys = null，直接赋值areas", "\r\n  ", "data", ".multiArray[", "1", "] = [];\r\n  ", "data", ".multiArray[", "2", "] = temp[", "data", ".multiIndex[", "0", "]].areas || [];\r\n }\r\n ", "this", ".setData({\r\n  multiArray: ", "data", ".multiArray,\r\n  multiIndex: ", "data", ".multiIndex,\r\n });\r\n }", "// 点击确定时 修改显示\r\nbindMultiPickerChange: function(e) {\r\n let {\r\n  multiArray,multiIndex\r\n } = this.data;\r\n let provinceName,\r\n  cityName,\r\n  districtName,\r\n  provinceId,\r\n  cityId,\r\n  districtId;\r\n provinceName = multiArray[", "0", "][", "multiIndex[0", "]].name;\r\n cityName = multiArray[", "1", "].length > 0 ? multiArray[", "1", "][", "multiIndex[1", "]].name : '';\r\n districtName = multiArray[", "2", "].length > 0 ? multiArray[", "2", "][", "multiIndex[2", "]].name : '';\r\n provinceId = multiArray[", "0", "][", "multiIndex[0", "]].code;\r\n cityId = multiArray[", "1", "].length > 0 ? multiArray[", "1", "][", "multiIndex[1", "]].code : '';\r\n districtId = multiArray[", "2", "].length > 0 ? multiArray[", "2", "][", "multiIndex[2", "]].code : '';\r\n this.setData({\r\n  provinceName,\r\n  cityName,\r\n  districtName,\r\n  provinceId,\r\n  cityId,\r\n  districtId,\r\n  region: provinceName + cityName + districtName,\r\n  showBottom:false\r\n })\r\n }", "以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持我们。", " "]}
{"title": "微信小程序中 setData 详解 ", "author": "Rolan", "pub_time": "2020-6-23 00:57", "content": [" \n                     \n                    ", "虽互不曾谋面,但希望能和您成为笔尖下的朋友", "以读书,技术,生活为主,偶尔撒点鸡汤", "不作,不敷衍,意在真诚吐露,用心分享", "点击 ", "左上方", " ,可关注本刊", "标星公众号（ ", "ID：itclanCoder ", "）", "如果不知道如何操作", "点击这里, ", "标星不迷路", "━━━━━━", "━━━━━━", "我希望您保持空杯", "一边阅读一边思考", "更重要是要动手敲", "如果有收获三连击", "作者  | 随笔川迹", "ID  | suibichuanji", "前言", "撰文:川川", "在", "小程序", "中各个页面之间是相互独立的,一个页面分为 ", "渲染层(视图层 webview)", " , ", "逻辑层(JavaScript)", " , ", "系统层(底层)", "在架构上， ", "WebView", " 和 ", "JavascriptCore", " 都是独立的模块，并不具备数据直接共享的通道", "换而言之,若要将逻辑层中的 ", "data", " 的数据渲染到页面中,他们之间是无法直接通信的,往往需要系统层作为中间角色", "我们都知道视图层的数据来源于逻辑层 data,而视图图层若想要改变逻辑层 data 的数据,需要借助 ", "setData", " 这个方法去触发,以达到更新视图层的数据,具体的工作过程是怎么样的?", "·  正   ·  文   ·  来   ·  啦   ·", "01", "setData是什么?", "定义 : 设置数据,更改数据", "作用: setData函数用于 ", "将数据从逻辑层发送到视图层(异步)", " , ", "同时改变对应的 ", " this.data ", "的值（同步）", "仔细细品这句话,会包含了很多信息", "setData它是微信小程序提供的一个内置的接口,是用于改变逻辑层中 data下的数据的", "视图层 view的数据挂载在逻辑层的 data下,发送到视图层中是异步的", "改变 this.data是同步,换句话说,若直接修改 this.data 而不调用 this.setData方法,是无法改变页面的状态的，还会造成数据不一致", "从上面的这张图中就可以看到, 当逻辑层data数据渲染到界面的时候,逻辑层的数据需要经过系统层 ,当系统层接收到这个逻辑层的数据后", "系统层在把数据转发给渲染层,然后在渲染层展示出来,在这个过程当中是异步的 ", "视图层和逻辑层的数据传输,实际上通过两边提供的 JavScript Core所实现,即用户传输的数据，需要将其转换为字符串形式传递", "同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立的环境", "02", "setData两个重要的参数", "从官方文档中看到这句Page.prototype.setData(Object data, Function callback),得知,setData方法是挂载当前页面实例Page原型下一个公用实例方法", "也就是说,Page 下面的任何一个方法内,都可以使用 setData 方法,它接收两个参数", "一个是Object data,第一个参数Object data是必传的,数据类型是Object,所代表的含义是,这次要改变的数据", "而第二个参数Function callback回调函数是非必填的,它所代表的含义是,setData引起的界面更新渲染完毕后的回调函数", "为了便于理解,在小程序中创建一个 page 页面,名为setdata,如下是逻辑层 js 文件", "/", "/ miniprogram/pages", "/setdata/setdata", ".js", "Page({", "  ", "/**", "   * 页面的初始数据", "   */", "  ", "data:", " {", "    ", "name", ":", " ", "\"itclanCoder\"", "  },", "  ", "/**", "   * 生命周期函数--监听页面加载", "   */", "  ", "onLoad:", " ", "function", " (", "options", ") ", "{", "  }", "})", "而 wxml 文件如下", "<!--miniprogram/pages/setdata/setdata.wxml-->", "<", "text", ">", "{{name}", "}", "</", "text", ">", "在Web 开发中，开发者使用JavaScript通过Dom接口来完成界面的实时更新。而在小程序中，使用WXML语言所提供的数据绑定功能，来完成此项功能", "在小程序中是没有DOM,BOM的那一套东西的,没有document.getElementById等的", "小程序是数据驱动视图的,逻辑层中的 data 数据改变了,视图层 view 也会跟着改变,它是单向数据流的,如果想要触发视图中数据的更新,那么就需要借助setData这个方法", "上面的WXML 通过{{变量名}}来绑定 WXML文件和对应的JavaScript文件中的data对象属性", "在上面的示例中,页面会显示itclanCoder,那如何更改逻辑层的数据呢", "在下面的示例中,演示了如何更改逻辑层的数据,在 wxml 中新增了一个按钮,用bindtap绑定了一个handleChangeName方法,触发按钮,改变 data 下的数据", "<!--miniprogram/pages/setdata/setdata.wxml-->", "<", "text", ">", "{{name}", "}", "</", "text", ">", "<", "button", " ", "type", "=", "\"primary\"", " ", "bindtap", "=", "\"handleChangeName\"", ">", "更改data中数据", "<", "/", "button", ">", "而在逻辑层 JS", "/", "/ miniprogram/pages", "/setdata/setdata", ".js", "Page({", "  ", "/**", "   * 页面的初始数据", "   */", "  ", "data:", " {", "    ", "name", ":", " ", "\"itclanCoder\"", "  },", "  ", "//", " 改变data的方法", "  handleChangeName() {", "    ", "console", ".log(", "\"name开始的数据\"", ", ", "this", ".data.name); ", "//", " itclanCoder", "    ", "this", ".setData({", "      ", "name", ":", " ", "\"川川\"", "    })", "    ", "console", ".log(", "\"name经过setData后的数据\"", ", ", "this", ".data.name); ", "//", " 川川", "  }", "})", "在上面的示例代码中,更改data下面的name字段值,使用的是setData方法,这个方法接收了一个参数,第一个参数是对象,这个Object 以 key: value 的形式表示，将 this.data中的 key对应的值改变成 value", "注意", "这个key可以以数据路径的形式给出,支持改变数组中的某一项或对象的某个属性，如 array[2].message，a.b.c.d，并且不需要在 this.data中预先定义,但凡是页面要显示的变量数据,最好先挂载在data下初始化定义,然后在使用", "也就是说在更改setData下的变量时,直接写key名就可以了的,不用写this.data.属性,如下所示", "this", ".setData({", "   ", "//", " this.data.name: ", "\"川川\"", " ", "//", " 这样写是会报错的", "   name: ", "\"川川\"", "               ", "//", " 正确的写法", "})", "而setData接收第二个参数,是一个Function callback", "handleChangeName() {", "    ", "console", ".log(", "\"name开始的数据\"", ", ", "this", ".data.name); ", "//", " itclanCoder", "    ", "this", ".setData({", "      ", "name", ": ", "\"川川\"", "    }, ", "()", " =>", " { ", "//", " 接收第二个回调函数", "       ", "console", ".log(", "\"执行setData引起的界面更新渲染完毕后的回调函数\"", ");", "    })", "    ", "console", ".log(", "\"name经过setData后的数据\"", ", ", "this", ".data.name); ", "//", " 川川", "  }", "上面代码的执行顺序是", "itclancoder", "川川", "执行", "set", "Data引起的界面更新渲染完毕后的回调函数", "此结果说明这个setData方法是异步的,等待主线程任务做完了,然后在去执行第二个参数,回调异步函数", "03", "如何更改某个对象下的属性", "有时候,我们的接口数据类型是对象,并非是基本数据类型(number,boolean,string,null),但由于业务需求,我们往往需要改变对象下的某个属性", "如下所示,我想改变person下的 age 属性值", "// miniprogram/pages/setdata/setdata.js", "Page({", "  ", "/**", "   * 页面的初始数据", "   */", "  data: {", "    ", "person", ": {", "      ", "name", ": ", "\"随笔川迹\"", ",", "      ", "sex", ": ", "\"男神\"", ",", "      ", "age", ": ", "20", "    }", "  },", "  handleChangeName() {", "    ", "this", ".setData({", "      ", "person", ": {", "        ", "age", ": ", "24", "      }", "    })", "  }", "})", "在上面的代码中,的确可以更改person对象下的age属性,但是随之带来的问题是,person对象下除了age属性,其他属性都消失了", "这非常令人郁闷", "那如何解决这个问题?", "方法 1: 指明具体的修改对象属性", "this", ".setData({", "   ", "\"person.age\"", ": ", "24", "  ", "// 注意要用双引号或单引号将属性给引起来", "})", "方法 2 :使用中扩号['对象.属性']:属性值", "this", ".setData({", "   [", "'person.age'", "]: ", "\"川川\"", "   ", "// 访问对象下的属性可以用.也可以用中括号,中间代表是一个变量,需要用引号引起来", "})", "如下所示", "这个在以后的开发中,很有用,有时候,在需要更改对象下的某个属性值的时候,就可以使用这种方式", "04", "setData注意事项", "直接修改 this.data,而不调用this.setData是无法改变页面的状态的，还会造成数据不一致", "仅支持设置可JSON化的数据,如果不是 JSON 对象数据格式,需要将数据进行转化成json对象`,key:value形式", "单次设置的数据不能超过1024kB(1M)，不要一次设置过多的数据(由于小程序运行逻辑线程与渲染线程之上,setData的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间,会增加脚本的编译执行时间，占用 WebView JS 线程，)", "不要把 data中任何一项的value设为undefined，否则这一项将不被设置并可能遗留一些潜在问题", "页面中需要显示的数据,可以挂载在data下面初始化,虽然这个值不一定要先设置,但是建议先声明然后在使用", "避免setData的调用过于频繁(setData接口的调用涉及逻辑层与渲染层间的线程通信,通信过于频繁可能导致处理队列阻塞,界面渲染不及时而导致卡顿,应避免无用的频繁调用)", "在Android下用户在滑动时会感觉到卡顿,操作反馈延迟严重,因为JS线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层,逻辑层亦无法及时将操作处理结果及时传递到视图层", "渲染有出现延时，由于WebView的 JS 线程一直处于忙碌状态，所以,逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不是实时的", "避免 setData 数据冗余(setData操作会引起框架处理一些渲染界面相关的工作,避免将未绑定在 WXML 的变量传入setData,减少不必要的性能消耗)", "后台态页面进行setData(比如退出小程序),当页面进入后台态（用户不可见），不应该继续去进行 setData，后台态页面的渲染用户是无法感受到的，另外后台态页面去 setData 也会抢占前台页面的执行", "结语", "在本文中主要介绍了下setData的使用,它是用于修改挂载在 data 下面的数据的,当想要修改视图 view,那么需要借助 setData 函数,它接收两个参数,第一个参数时必传的,也就是要修改视图 view 层的对象,而第二个参数时非必传的", "setData 将数据从逻辑层发送到视图层是异步,同时改变对应的this.data的值是同步,它并不是实时的,这也导致了必须要考虑性能的因素", "从而介绍了 setData 的使用注意事项,值得注意的是,如何修改对象下的某个属性,这个在往后的开发中,是使用比较频繁的.", "如果小伙伴们有问题,欢迎大家下面留言,一起学习讨论", " "]}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": [" \n                     \n                    ", "编辑名片有两条路径，分为新增名片流程与修改名片流程。", "用户手填新增名片流程：", "首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。", "新增名片页面 1 基本布局如下：", "取到 userId。", "使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。", "也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。", "这里绑定了自带的模态框提示组件。", "其中 modalHidden2 是模态框开关。", "另外 proptText 是需要提示的内容。", "即使很多输入框也支持数据动态改变，非常方便。", "实际效果，非常快捷，比以前省去很多事情，编写", "小程序", "，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。", "最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。", "设置的直接是背景图片。", "提交表单与跳转。", "提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。", "这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。", "同样也是一些数据绑定以及验证效果。", "实际渲染效果可以看到。", "这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。", "修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：", "名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：", "姓名手机必填模块：", "个人信息模块，直接循环（block）出来：", "Onload 时我们请求必填与选填数据：", "* requiredGroup 必填中文信息", "* notRequiredGroup 选题中文信息", "* requiredGroupEn 必填英文信息", "* notRequiredGroupEn 选题英文信息", "```", "//请求名片对应的公司的中文信息的属性组数据，分为必填和选填", "//选题项变量以 no 开头", "requester.getOfflineCardInfoGroupFields(userId, cardId,", "function (res) {", "//debugger", "var userName = res.card.userName;", "var mobile = res.card.mobile;", "var requiredGroup = res.requiredGroupCh;", "var notRequiredGroup = res.notRequiredGroupCh;", "var requiredGroupEn = res.requiredGroupEn;", "var notRequiredGroupEn = res.notRequiredGroupEn;", "var reqLen = requiredGroup.fields.length;", "var nreqLen = notRequiredGroup.fields.length;", "var reqLenEn = requiredGroupEn.fields.length;", "var nreqLenEn = notRequiredGroupEn.fields.length;", "self.setData({", "userName: userName,", "mobile: mobile,", "requireFields: requiredGroup.fields,", "notRequireFields: notRequiredGroup.fields,", "requireFieldsEn: requiredGroupEn.fields,", "notRequireFieldsEn: notRequiredGroupEn.fields,", "l1: reqLen,", "l2: nreqLen + reqLen,", "l3: reqLenEn + nreqLen + reqLen", "});", "self.forceUpdate();", "}, function (code, msg) {", "console.info(\"code=\" + code + \"&msg=\" + msg);", "});", "```", "中英文信息必填与选填渲染：", "这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。", "今天再回去理下首页 A、B、C 定点跳转功能实现方法。", "首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：", "数据 sort，和 group.name 数据一样：", "这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。", "点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。", "首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。", "可以看下：", "这个 group.name==sortmsg，等于就是 A==A,B==B 同理。", "在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。", "跳转功能基本实现（ohter 就是 # 底部）。", " "]}
{"title": "解决微信小程序引用echarts视图模糊的问题 ", "author": "Rolan", "pub_time": "2020-4-27 00:39", "content": [" \n                     \n                    ", "在", "小程序", "项目中需要用到echarts图表", "但是展示的时候遇到了问题 图表高度失真 体验感非常差", "经过一番查找实验，终于找到了解决方案", "下面上代码！", "function initChart(canvas, width, height,dpr) {", "const chart = echarts.init(canvas, null, {", "width: width,", "height: height,", "devicePixelRatio: dpr //解决小程序视图模糊的问题，必写", "});", "canvas.setChart(chart);", "var checkName = ‘今天’;", "var dataLength = 14; //默认的数据长度，既真实数组的长度，必须设置，长度来源：后台传输", "//这里是echart基础配置", "var option = {", "backgroundColor: ‘rgba(25,1,169,.05)’,", "tooltip: {", "trigger: ‘axis’,", "axisPointer: {", "type: ‘shadow’,", "backgroundColor: ‘rgba(245, 245, 245, 1)’,", "borderWidth: 1,", "// padding: 10,", "}", "},", "dataZoom: [{", "show: false, //是否显示下方滚动条", "realtime: true,", "startValue: dataLength – 7,", "endValue: dataLength – 1, //显示数据结束位置", "},", "{", "type: ‘inside’,", "realtime: true,", "startValue: dataLength – 7,", "endValue: dataLength – 1, //显示数据结束位置", "}", "],", "grid: {", "top: ‘20%’,", "right: ‘0’,", "left: ‘0’,", "bottom: ‘12%’", "},", "xAxis: [{", "type: ‘category’,", "data: [‘02.25’, ‘02.26’, ‘02.27’, ‘02.28’, ‘03.01’, ‘03.02’, ‘03.02’, ‘02.25’, ‘02.26’, ‘02.27’, ‘02.28’, ‘03.01’, ‘03.02’, ‘今天’],", "axisLine: {", "lineStyle: {", "color: ‘rgba(255,255,255,0.12)’", "}", "},", "position: ‘top’,", "axisLabel: {", "color: function(params) {", "//通过判断选中的名字改变柱子的颜色样式", "if (checkName === params) {", "return ‘rgba(38,74,255,1)’;", "} else {", "return ‘rgba(38,74,255,.3)’;", "}", "},", "textStyle: {", "fontSize: 14", "},", "padding: [10, 0]", "},", "}],", "yAxis: [{", "show: false,", "axisLabel: {", "formatter: ‘{value}’,", "color: ‘#e2e9ff’,", "},", "axisLine: {", "show: false", "},", "splitLine: {", "lineStyle: {", "color: ‘rgba(255,255,255,0.12)’", "}", "}", "}],", "series: [{", "type: ‘bar’,", "data: [300, 450, 770, 203, 255, 188, 156, 300, 450, 770, 203, 255, 188, 156],", "// itemStyle: {", "//     normal: {", "//         color: ‘rgba(38,74,255,.3)’,", "//     }", "// },", "itemStyle: {", "normal: {", "label: {", "show: true", "},", "color: function(params) {", "//通过判断选中的名字改变柱子的颜色样式", "if (checkName === params.name) {", "return ‘rgba(38,74,255,1)’;", "} else {", "return ‘rgba(38,74,255,.3)’;", "}", "}", "}", "},", "label: {", "normal: {", "show: true,", "position: ‘top’,", "textStyle: {", "color: ‘#B9C5FC’,", "fontSize: ’12’", "},", "formatter: ‘{c}分’", "}", "}", "}]", "};", "chart.setOption(option);", "return chart;", "}", "在小程序的data里面调用", "这样就解决了 解决后的效果图", " "]}
{"title": "微信小程序|动态时钟 ", "author": "Rolan", "pub_time": "2020-5-2 00:02", "content": [" \n                     \n                    ", "问题描述", "近期，网络上流行了一个“时间管理”的梗，想要做好时间管理，清楚把握时间才是关键点，那么借着这个“时间管理”，来介绍一个", "小程序", "实现动态时钟的案例吧。", "效果图：", "图", "2.1 ", "动态时钟", "解决方案", "1、wxml", "wxml", "代码十分简单，只需要一个", "canvas", "组件便能实现一个时钟外圆形状。", "<canvas  canvas-id='myCanvas'></canvas>", "2、js", "js", "部分主要针对于", "Math", "相关属性的应用。", "（1）指针的配置：", "指针都要对运动路径进行适当的设置，需要利用", "Math.PI", "属性来对不同指针转动角度进行配置。比如，秒针转动角度", "Math.PI/30", "表示将整个圆", "(360", "°", ")", "平分为", "60", "份，即一秒转过", "6", "°；分针、时针的计算同理。指针转动到某个点，存在一个坐标，坐标的计算需要利用", "Math.sin", "、", "Math.cos", "属。", "（2）方法为：假设圆心坐标为", "(a,b)", "，则", "x=a + Math.sin(angle * (Math.PI / 180)) * r ", "；", "y=b -Math.cos(angle * (Math.PI / 180)) * r ", "。", "（3）表盘、数字点：", "arc(x,y,半径,", "起始位置，结束位置", ")", "3、代码示例：", "（", "1", "）先定义将要直接执行的几个函数", "  onShow:  function (e) {", "     setInterval(show, 1000); //", "每秒执行", "1", "次", "     function show() {", "       secshow() //", "秒针", "       minshow() //", "分针", "       houshow() //", "时针", "       backshow() //", "表盘", "       numbershow() //", "数字", "       ctx.draw()", "     }", "   },", "（", "2", "）秒针", "function secshow() {", "   var now = new Date()", "   var sec = now.getSeconds()", "   //", "角度弧度", "   var angle = sec * Math.PI / 30", "   var x = 100 * Math.sin(angle) + 150", "   var y = 150 - 100 * Math.cos(angle)", "   ctx.beginPath() #", "开始路径", "  ctx.setLineWidth(5)  //", "线条粗细", "   ctx.setStrokeStyle('black')", "   ctx.moveTo(150, 150)", "   ctx.lineTo(x, y) //", "指针指向", "   ctx.closePath() //", "返回初始状态", "   ctx.stroke() //", "描出点的路径", "}", "（", "3", "）分针", "function minshow() {", "   var now = new Date()", "   var min = now.getMinutes()", "   var sec = now.getSeconds()", "   var angle = (min + sec / 60) * Math.PI / 30", "   var x = 80 * Math.sin(angle) + 150", "   var y = 150 - 80 * Math.cos(angle)", "   ctx.beginPath()", "   ctx.setLineWidth(5)", "   ctx.setStrokeStyle('black')", "   ctx.moveTo(150, 150)", "   ctx.lineTo(x, y)", "  ctx.closePath()", "   ctx.stroke()", "}", "（", "4", "）时针", "function houshow() {", "   var now = new Date()", "   var hou = now.getHours()", "   hou = hou % 12  //24", "小时制，取余数", "   var min = now.getMinutes()", "   var sec = now.getSeconds()", "   var angle = (hou + min / 60 + sec / 3600) * Math.PI / 6", "   var x = 50 * Math.sin(angle) + 150", "   var y = 150 - 50 * Math.cos(angle)", "   ctx.beginPath()", "   ctx.setLineWidth(8)", "   ctx.moveTo(150, 150)", "   ctx.lineTo(x, y)", "   ctx.closePath()", "   ctx.stroke()", "}", "(5)", "表盘及数字点", "function backshow() {", "   ctx.beginPath()", "  ctx.setLineWidth(3)", "   ctx.arc(150, 150, 110, 0, 2 * Math.PI)", "   ctx.closePath()", "   ctx.stroke()", "}", " ", "function numbershow() {", "   ctx.beginPath()", "   ctx.setFontSize(20)", "   for (var i = 1; i < 13; i++) {", "     var angle = i * Math.PI / 6", "     var x = 100 * Math.sin(angle) + 145", "     var y = 158 - 100 * Math.cos(angle)", "     ctx.fillText(i, x, y)", "  }", "}", " ", " "]}
{"title": "做好内容安全检测，和风险说「再见」！ ", "author": "Rolan", "pub_time": "2020-5-12 00:11", "content": [" \n                     \n                    ", "前言", "内容安全检测，是每一个", "小程序", "主都面临的“头疼”问题，轻则短暂性不可访问，重则永久封号，甚至关小黑屋。本文将为您详细说明，如何在小程序中对一段文本进行合法内容检测，以判断是否含有违法违规内容。", "本文重点为你讲述：", "内容安全检测常见应用场景及解决办法", "学会使用小程序·云开发的云函数+结合request-promise第三方库实现内容请求校验", "掌握如何在小程序端请求云函数（有别于传统的wx.request的方式(类似AJax)）", "在云开发的云函数端,利用第三方https请求库(request,request-promise),获取Access_token,以及向微信官方提供的内容检测接口发请求进行校验", "云函数端与小程序端错误码的处理", "01.背景", "无论是小程序还是自行开发的一些类似社交,带有用户自行产生内容的软件应用,例如:即时通讯,社群,论坛,音视频直播等,对于接入内容安全的检测是非常有必要的。", "对于小程序而言,这一点在审核上是非常严格的,净化言行,做一个知法守法的人很重要...", "接入内容安全检测,规避输入一些违法违规低俗等内容,避免辛辛苦苦开发出来的应用。", "被恶意上传反动言论或上传一些违规内容(文字/图片/视频等),导致小程序或应用被下架,或遭永久禁封,或个人及公司被公安机关打电话,约喝茶等,这样的话,就得不偿失了的。", "02.应用场景", "检测小程序用户个人文字资料是否违规", "针对特点词汇（如过于商业以及营销之类的词）可以进行过滤或禁止输入", "在内容发布之前自动检测用户发表的信息（包括评论、留言等）是否违规", "03.解决办法", "围绕如何处理内容安全检测问题，一般有3种方法：", "方案1****:引入第三方接口对内容进行校验(例如:百度AI内容审核平台,网易云盾等)", "方案2: 公司后台小伙伴自行开发文本,图片,音视频等内容审核接口", "方案3: 小程序服务端提供的API进行校验", "每一种方法各有优劣势，具体如下图。", "解决方案", "优势", "劣势", "1", "引入第三方接口对内容进行校验", "前端同学只需按照官方提供的第三方接口文档,进行校验即可,无需后台介入,功能强大,覆盖范围广", "接口调用的频次有限制,收费", "2", "公司后台小伙伴自行开发文本,图片,音视频等内容审核接口", "后台小伙伴自己造轮子,根据自己的业务需求以及用户属性,自定义内容审核机制", "开发周期长,成本大,难以覆盖全面", "3", "调用小程序服务端提供的内容安全API进行校验", "简单,高效", "想不出来,因为相比前两种方案,对于不依赖后端接口的开发者来说,简直是雪中送炭", "在微信小程序生态下，官方提供了2种路径帮助用户解决内容检测问题，即", "使用服务器开发模式，通过HTTPS调用", "使用小程序·云开发，通过云函数或云调用来实现。", "服务器开发模式，相信大家都相对比较熟悉，在此就不再赘述。接下来为大家重点介绍，如何通过小程序·云开发的云函数实现内容安全检测。", "04.通过云开发的云函数+request-promise第三方库实现内容请求校验", "Step 1: 在小程序端先布局：完成静态页面。(pages文件夹下的文件都是属于小程序前端代码,每个文件夹目录代表的就是一个模块,一个页面)", "小程序前端wxml代码示例", "<view ", "class", "=", "\"container\"", ">\r\n  <textarea ", "class", "=", "\"content\"", " placeholder=", "\"写点文字...\"", " bindinput=", "\"onInput\"", " auto-focus bindfocus=", "\"onFocus\"", " bindblur=", "\"onBlur\"", ">\r\n  </textarea>\r\n</view>\r\n\r\n<view ", "class", "=", "\"footer\"", ">\r\n  <button ", "class", "=", "\"send-btn\"", " size=", "\"default\"", " bind:tap=", "\"send\"", ">发布</button>\r\n</view>", "小程序前端wxss代码示例", "/* pages/msgSecCheck/msgSecCheck.wxss */", "\r\n", ".container", " {\r\n  ", "padding", ": ", "20", "rpx;\r\n}\r\n\r\n", ".content", " {\r\n  ", "width", ": ", "100%", ";\r\n  ", "height", ": ", "360", "rpx;\r\n  ", "box-sizing", ": border-box;\r\n  ", "font-size", ": ", "32", "rpx;\r\n  ", "border", ": ", "1px", " solid ", "#ccc", ";\r\n}\r\n\r\n", ".footer", " {\r\n  ", "width", ": ", "100%", ";\r\n  ", "height", ": ", "80", "rpx;\r\n  ", "line-height", ": ", "80", "rpx;\r\n  ", "position", ": fixed;\r\n  ", "bottom", ": ", "0", ";\r\n  ", "box-sizing", ": border-box;\r\n  ", "background", ": ", "#34bfa3", ";\r\n}\r\n\r\n", ".send-btn", " {\r\n  ", "width", ": ", "100%", " ", "!important", ";\r\n  ", "color", ": ", "#fff", ";\r\n  ", "font-size", ": ", "32", "rpx;\r\n}\r\n\r\n", "button", " {\r\n  ", "width", ": ", "100%", ";\r\n  ", "background", ": ", "#34bfa3", ";\r\n  ", "border-radius", ": ", "0", "rpx;\r\n}\r\n\r\n", "button", "::after", " {\r\n  ", "border-radius", ": ", "0", "rpx ", "!important", ";\r\n}", "经过wxml与wxss的编写后,UI最终长成这样", "Step 2: 完成小程序端业务逻辑的处理", "小程序端逻辑JS代码示例", "// pages/msgSecCheck/msgSecCheck.js", "\r\nPage({\r\n\r\n  ", "/**\r\n   * 页面的初始数据\r\n   */", "\r\n  data: {\r\n    ", "textareaVal", ": ", "''", "   ", "// 页面中需要显示的数据,初始化定义在data下面", "\r\n  },\r\n\r\n  ", "/**\r\n   * 生命周期函数--监听页面加载\r\n   */", "\r\n  onLoad: ", "function", " (", "options", ") ", "{\r\n\r\n  },\r\n  ", "// 监听表单时,数据有变化时", "\r\n  onInput(event) {\r\n    ", "let", " textVal = event.detail.value;\r\n    ", "this", ".setData({\r\n      ", "textareaVal", ": textVal\r\n    })\r\n    \r\n  },\r\n\r\n  ", "// 聚焦焦点时", "\r\n  onFocus() {\r\n    ", "console", ".log(", "'聚焦焦点时'", ");\r\n  },\r\n\r\n  ", "// 失去焦点时", "\r\n  onBlur(event) {\r\n    ", "console", ".log(", "\"失去焦点时\"", ");\r\n    ", "// 前端可进行手动的弱校验,也可以在失去焦点时发送请求进行文本的校验,但是每次失去焦点就请求一次,这样是消耗云资源的,在发布时候与失去焦点做校验两者都可以", "\r\n\r\n\r\n  },\r\n\r\n  ", "// 发布", "\r\n  send() {\r\n    ", "console", ".log(", "\"触发发布按钮\"", ")\r\n    wx.cloud.callFunction({ ", "// 请求msgSecCheck1云函数", "\r\n      name: ", "'msgSecCheck1'", ",\r\n      ", "data", ": {\r\n        ", "content", ": ", "this", ".data.textareaVal ", "// 需要向云函数msgSecCheck1传入的值", "\r\n      }\r\n\r\n    }).then(", "res", " =>", " { ", "// 成功时的响应返回结果", "\r\n      ", "console", ".log(res);\r\n    }).catch(", "err", " =>", " { ", "// 失败时,返回的结果", "\r\n      ", "console", ".error(err);\r\n    })\r\n    \r\n  }\r\n\r\n})", "Step 3 ：服务端逻辑处理。在小程序云函数端创建云函数msgSecCheck1,这个名字你可以自定义,与小程序前端请求的名字保持一致就可以了。", "选中云函数,右键并打开命令行终端安装request,request-promise，因为request-promise依赖于request,两个都要安装,最后一键上传部署就可以了", "npm ", "install", " request\r\nnpm ", "install", " request-promise", "如果遇到在小程序端请求云函数时,遇到类似下面的错误,找不到什么xxx模块之类的 先看错误码,然后在官方文档中找到该错误码代表的含义", "一看错误,没有找到模块,在云函数的目录下的package.json中查看是否有安装错误中提示的包的,要是没有的话,就安装一下就可以了的,同时记得每次更改后都要上传部署一下,也可以选择云函数中文件的增量上传", "接下来是将是本文的重点内容！", "Step 4 :通过云函数+****request-promise实现内容安全检测", "对于小程序开发,其实与web端开发也是类似,给元素绑定事件,然后获取元素,只是小程序端没有DOM,BOM的那一套东西,它是数据驱动视图的,吸收了Angular,Vue,React的各个框架的优点,形成了自己的一套规范。", "如果有这方面开发经验的小伙伴来说,平缓过度到小程序开发当中来,你会发现总会有惊人的相似,用的语言都是JavaScript,但是与web开发还是多少有很多差异的,这里就不拓展了。", "废话不多说,直接上代码 ：", "小程序前端逻辑代码：", "// 点击发送按钮,对输入的文本内容进行校验", "\r\n ", "send", "() {\r\n    ", "wx", ".cloud", ".callFunction", "({\r\n      ", "name", ": ", "'msgSecCheck1'", ", ", "// 云函数的名称", "\r\n      ", "data", ": { ", "// 需要向云函数传递过去的数据", "\r\n        ", "content", ": this.data.textareaVal ", "// 具体要检测的内容", "\r\n      }\r\n    })", ".then", "(res => { ", "// 成功时,做什么事情", "\r\n      ", "console", ".log", "(res);\r\n      ", "// 检测到文本成功时,做一些业务", "\r\n\r\n    })", ".catch", "(err => { ", "// 失败时,做什么事情", "\r\n      ", "// 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作", "\r\n\r\n      ", "console", ".error", "(err);\r\n    })\r\n  }", "上面的代码还可以在优化一下,就是将请求云函数的代码封装成一个函数。", "如下所示,不封装也是没事的,只是我习惯性封装一下,如果其他地方也用到该云函数,那么直接调用，避免写重复的代码。", "下面是将请求云函数的部分核心代码：", "// 发布", "\r\n  send() {\r\n    ", "// 请求msgSecCheck1云函数,对文本内容进行校验", "\r\n    ", "this", "._requestCloudMsgCheck();\r\n  },\r\n\r\n  _requestCloudMsgCheck() {\r\n    ", "let", " textareaVal = ", "this", ".data.textareaVal;\r\n    wx.cloud.callFunction({\r\n      ", "name", ": ", "'msgSecCheck1'", ",\r\n      ", "data", ": {\r\n        ", "content", ": textareaVal ", "// 这里可以使用官方文档测试用例,特3456书yuuo莞6543李zxcz蒜7782法fgnv级", "\r\n      }\r\n    }).then(", "res", " =>", " {\r\n      ", "console", ".log(res);\r\n      ", "// 检测到文本成功时,做一些业务", "\r\n    }).catch(", "err", " =>", " {\r\n      ", "// 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作", "\r\n      ", "console", ".error(err);\r\n    })\r\n  }", "至于是在失去焦点事件时发送请求还是在点击发送按钮时发送请求,两种方式都可以。", "您也可以自定义文本校验,而我个人觉得在小程序端,失去焦点时,可以自定义做一些常规敏感词的弱校验,而在点击发送按钮时,做强校验 。", "如果是放在失去焦点时就立马请求,这样请求次数会增多,而放在点击发送按钮时进行校验,一定程度上可以减少小程序端频繁请求。", "接下来就是处理云函数端,使用request-promise请求请求微信内容安全接口的示例代码。", "/*\r\n *  Description: 利用第三方库request-promise请求微信内容安全接口\r\n *\r\n * 相关文档链接:\r\n * 微信文本内容安全接口文档https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html\r\n * access_token获取调用凭证文档\r\nhttps://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\r\n *\r\n * request-promise使用文档: https://github.com/request/request-promise\r\n *\r\n */", "\r\n\r\n", "const", " APPID = ", "\"wx21baa58c6180c2eb\"", "; ", "// 注意是你自己小程序的appid", "\r\n", "const", " APPSECRET = ", "\"\"", "; ", "// 你自己小程序的appsecret", "\r\n", "// 安全校验接口", "\r\n", "const", " msgCheckURL = ", "`https://api.weixin.qq.com/wxa/msg_sec_check?access_token=`", ";\r\n", "// 向下面的这个地止发送请求,携带appid和appsecret参数,获取token认证", "\r\n", "const", " tokenURL = ", "`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=", "${APPID}", "&secret=", "${APPSECRET}", "`", "\r\n", "// 云函数入口文件", "\r\n", "const", " cloud = ", "require", "(", "'wx-server-sdk'", ")\r\n\r\ncloud.init()\r\n\r\n", "// 引入request-promise", "\r\n", "const", " rp = ", "require", "(", "'request-promise'", ");\r\n\r\n", "// 云函数入口函数", "\r\nexports.main = ", "async", "(event, context) => {\r\n  ", "try", " {\r\n    ", "let", " tokenResponse = ", "await", " rp(tokenURL);\r\n    ", "// 获取token值,因为返回的结果是字符串,需要用JSON.parse转化为json对象", "\r\n    ", "let", " getAccessToken = ", "JSON", ".parse(tokenResponse).access_token;\r\n    ", "// 请求微信内容安全接口,post请求,返回最终的校验结果", "\r\n    ", "let", " checkResponse = ", "await", " rp({\r\n      ", "method", ": ", "'POST'", ",\r\n      ", "url", ": ", "`", "${msgCheckURL}", "${getAccessToken}", "`", ",\r\n      ", "body", ": {\r\n        ", "content", ": event.content ", "// 这里的event.content是小程序端传过来的值,content是要向内容接口校验的内容", "\r\n      },\r\n      ", "json", ": ", "true", "\r\n    })\r\n    ", "return", " checkResponse;\r\n  } ", "catch", " (err) {\r\n      ", "console", ".error(err);\r\n  }\r\n}", "当你在小程序端输入文本,发送请求时,查看控制台下的结果时,功能是没有问题的。", "特3456书yuuo莞6543李zxcz蒜7782法fgnv级\r\n完2347全dfji试3726测asad感3847知qwez到", "您可以根据官方文档中提供的测试用例,进行测试,看具体的返回结果的。", "（控制台错误码）", "(合规内容)", "云函数请求成功,看看错误信息的反馈,对于熟悉该错误码的人清楚该文本违规了,但是反馈不是很明显,即使当下自己很清楚,然而,在过几个月在回来看代码,你或许都不知道是啥意思。", "Step 5 ：错误码的正确处理方式", "对于处理错误码,返回具体的合适信息,对于调试代码,排查问题,也是非常重要 。", "这些错误码具体的含义,在官方文档里都有对应的解释,不用去记,去查文档就行。", "在面试中,有很多面试官喜欢问http相关状态码的问题,状态码有很多,也真的记不住,但是常见的错误http状态码还是要知道的,我觉得,具体知道怎么处理,怎么查文档就可以了。", "真正考验背后目的是,对于根据后端返回的状态码,判断接口哪里出了问题,定位是前端问题还是后端问题,这是一个非常常见的问题。", "如果你说你不知道,没有处理过,对于候选人,那肯定是没有信服力的,无论是成功状态还是失败状态,都是应该有对应的用户提示。", "05.完整文本安全校验示例代码", "/*\r\n *\r\n * 相关文档链接:\r\n * 微信文本内容安全接口文档https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html\r\n * access_token获取调用凭证文档\r\nhttps://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\r\n *\r\n * request-promise使用文档: https://github.com/request/request-promise\r\n *\r\n */", "\r\n\r\n", "const", " APPID = ", "\"wx21baa58c6180c2eb\"", ";\r\n", "const", " APPSECRET = ", "\"\"", ";\r\n\r\n", "const", " msgCheckURL = ", "`https://api.weixin.qq.com/wxa/msg_sec_check?access_token=`", ";\r\n", "// 向下面的这个地止发送请求,携带appid和appsecret参数,获取token认证", "\r\n", "const", " tokenURL = ", "`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=", "${APPID}", "&secret=", "${APPSECRET}", "`", "\r\n", "// 云函数入口文件", "\r\n", "const", " cloud = ", "require", "(", "'wx-server-sdk'", ")\r\n\r\ncloud.init()\r\n\r\n", "// 引入request-promise", "\r\n", "const", " rp = ", "require", "(", "'request-promise'", ");\r\n\r\n", "// 云函数入口函数", "\r\nexports.main = ", "async", "(event, context) => {\r\n  ", "try", " {\r\n    ", "let", " tokenResponse = ", "await", " rp(tokenURL);\r\n    ", "// 获取token值,因为返回的结果是字符串,需要用JSON.parse转化为json对象", "\r\n    ", "let", " getAccessToken = ", "JSON", ".parse(tokenResponse).access_token;\r\n    ", "// 请求微信内容安全接口,post请求,返回最终的校验结果", "\r\n    ", "let", " checkResponse = ", "await", " rp({\r\n      ", "method", ": ", "'POST'", ",\r\n      ", "url", ": ", "`", "${msgCheckURL}", "${getAccessToken}", "`", ",\r\n      ", "body", ": {\r\n        ", "content", ": event.content ", "// 这里的event.content是小程序端传过来的值,content是要向内容接口校验的内容", "\r\n      },\r\n      ", "json", ": ", "true", "\r\n    })\r\n\r\n    ", "// 有必要根据错误码,确定内容是否违规", "\r\n    ", "if", " (checkResponse.errcode == ", "87014", ") {\r\n      ", "return", " {\r\n        ", "code", ": ", "500", ",\r\n        ", "msg", ": ", "\"内容含有违法违规内容\"", ",\r\n        ", "data", ": checkResponse\r\n      }\r\n    } ", "else", " {\r\n      ", "return", " {\r\n        ", "code", ": ", "200", ",\r\n        ", "msg", ": ", "\"内容OK\"", ",\r\n        ", "data", ": checkResponse\r\n      }\r\n    }\r\n  } ", "catch", " (err) {\r\n    ", "if", " (err.errcode == ", "87014", ") {\r\n      ", "return", " {\r\n        ", "code", ": ", "500", ",\r\n        ", "msg", ": ", "'内容含有违法违规内容'", ",\r\n        ", "data", ": err\r\n      }\r\n    } ", "else", " {\r\n      ", "return", " {\r\n        ", "code", ": ", "502", ",\r\n        ", "msg", ": ", "'调用msgCheckURL接口异常'", ",\r\n        ", "data", ": err\r\n      }\r\n    }\r\n  }\r\n}", "在云函数端,经过添加错误码的判断之后,在来看看小程序端发送的请求,返回的结果。", "（这与没有添加错误码判断,是不一样的,有具体的错误信息内容）", "至此,我们在小程序端可以根据这个返回的错误码或成功码,进行一些业务逻辑处理的,比如给一些用户提示,在数据插入数据库之前就做一些判断操作,只有内容合规时,才插入数据库,进入下一步的业务逻辑处理。", "_requestCloudMsgCheck() {\r\n    ", "let", " textareaVal = ", "this", ".data.textareaVal;\r\n    wx.cloud.callFunction({\r\n      ", "name", ": ", "'msgSecCheck1'", ",\r\n      ", "data", ": {\r\n        ", "content", ": textareaVal\r\n      }\r\n    }).then(", "res", " =>", " {\r\n      ", "console", ".log(res);\r\n      ", "const", " errcode = res.result.data.errcode;\r\n      ", "// 检测到文本错误时,做一些业务", "\r\n      ", "if", " (", "87014", " === errcode) {\r\n         wx.showToast({ ", "// 当内容违规时,做一些用户提示", "\r\n           title: ", "'您输入的文本内容含有敏感内容,请重新输入'", ",\r\n         })\r\n      }", "else", " {\r\n         ", "// 成功时做其他业务操作", "\r\n      }\r\n    }).catch(", "err", " =>", " {\r\n      ", "// 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作", "\r\n      ", "console", ".error(err);\r\n    })\r\n  }", "(当输入的内容有违规时,给一些用户提示或者阻止下一步操作等的)", "注意在云函数(后)端处理错误码与小程序端都是要进行处理的,两者不要混淆了的,小程序端最终的一些业务逻辑判断,是根据后端接口返回的状态,最终决定要做什么操作的。", "至此,通过request-promise库就完成了文本内容校验的问题。", "这个request,request-promise库非常实用,功能也非常强大,类似这种库,常见什么got,axios等之类的,都是支持promise风格的 处理方式大同小异,大家可以去npm或github上阅读相关使用文档的。", "06.结语", "在小程序中有多种解决方案,推荐使用小程序端请求云开发云函数的方式,无论是不使用云函数方式,自己有后端服务,获取access_token都应该是从后端返回给前端的。", "而小程序的秘钥 AppSecret是不应该放在小程序端的,那样不安全的,无论是服务器开发模式还是小程序·云开发模式,都绕不过后台请求微信提供的内容安全接口,然后在返回给小程序端 。", "其实在小程序·云开发中,还提供了一种更简便的方法,那就是云调用,它是小程序·云开发提供的在云函数中调用微信开放接口的能力,只需简单的进行配置一下就可以了。", "限于篇幅所致,放在下一节介绍。", "reference:方案1参考链接:", "微信内容安全:", "https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html", "云调用", "https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/capabilities.html#%E4%BA%91%E5%87%BD%E6%95%B0", "百度文本审核", "https://ai.baidu.com/tech/textcensoring", "网易云盾", "https://dun.163.com/product/text-detection", "公众号：腾讯云云开发", "腾讯云云开发： ", "https://cloudbase.net", "云开发控制台： ", "https://console.cloud.tencent.com/tcb?from=12304", " "]}
{"title": "微信小程序直播 ", "author": "Rolan", "pub_time": "2020-5-18 00:49", "content": [" \n                     \n                    ", "1.添加直播组件", "官方开发文档", "以mpvue为例", "//app.json", "\r\n", "\"plugins\"", ": {\r\n  ", "\"live-player-plugin\"", ": {\r\n    ", "\"version\"", ": ", "\"1.0.11\"", ",\r\n    ", "\"provider\"", ": ", "\"wx2b03c6e691cd7370\"", "\r\n  }\r\n}\r\n复制代码", "直播组件版本号可以在 ", "微信开发者工具-详情-基本信息-插件信息", " 查看当前版本号以及最新版本号", "2.直播间跳转", "以navigateTo为例", "let", " roomId = [直播房间id] ", "// 填写具体的房间号", "\r\n", "let", " customParams = ", "encodeURIComponent", "(", "JSON", ".stringify({\r\n  ", "path", ": ", "'pages/index/index'", ",\r\n  ", "pid", ": ", "1", " \r\n})) ", "// 开发者在直播间页面路径上携带自定义参数", "\r\n", "let", " livePath = ", "'plugin-private://wx2b03c6e691cd7370/pages/live-player-plugin'", "\r\nwx.navigateTo({", "// 其中wx2b03c6e691cd7370是直播组件appid不能修改", "\r\n    url: ", "`", "${livePath}", "?room_id=", "${roomId}", "&custom_params=", "${customParams}", "`", "\r\n})\r\n复制代码", "3.获取直播间列表以及获取直播状态", "直播间列表调用限额 ", "500", " 次/天，建议开发者自己做缓存，交给后端处理了！", "let", " livePlayer = requirePlugin(", "'live-player-plugin'", ")\r\n", "// 首次获取立马返回直播状态，往后间隔1分钟或更慢的频率去轮询获取直播状态", "\r\n", "const", " roomId = xxx ", "// 房间 id", "\r\nlivePlayer.getLiveStatus({ \r\n    ", "room_id", ": roomId\r\n}).then(", "res", " =>", " {\r\n    ", "// 101: 直播中, 102: 未开始, 103: 已结束, 104: 禁播, 105: 暂停中, 106: 异常，107：已过期 ", "\r\n    ", "const", " liveStatus = res.liveStatus\r\n    ", "console", ".log(", "'get live status'", ", liveStatus)\r\n}).catch(", "err", " =>", " {\r\n    ", "console", ".log(", "'get live status'", ", err)\r\n})\r\n复制代码", "4.直播订阅", "对于未开播场次进行订阅", "//页面json文件添加subscribe组件", "\r\n", "usingComponents", ": {\r\n    ", "subscribe", ": ", "'plugin-private://wx2b03c6e691cd7370/components/subscribe/subscribe'", "\r\n}\r\n复制代码", "//写入直播房间id即可", "\r\n", "<", "subscribe", " ", "room-id", "=", "\"[直播房间id]\"", ">", "</", "subscribe", ">", "\r\n复制代码", "5.mpvue-config-loader大坑", "插件简化了页面config配置，但在 ", "usingComponents", " 遍历的时候为所有属性值添加了一个 ", "/", " ，就导致获取不到 ", "subscribe", " 组件，暂时先对 ", "mpvue-config-loader", " 插件做一下更改。", "//node_modules/mpvue-config-loader/index.js 46-48行", "\r\n", "//可将其3行注释掉，或者去掉47行 /", "\r\n", "if", " (parentKey === ", "'usingComponents'", " && !path.isAbsolute(node.value)) {\r\n  ", "return", " ", "`/", "${node.value}", "`", "\r\n}\r\n复制代码", "6.获取分享卡片链接参数", "以mpvue为例，在 ", "./src/App.vue", " 文件中添加以下代码", "onShow(", "options", ") {\r\n  ", "// 分享卡片入口场景才调用getShareParams接口获取以下参数", "\r\n  ", "if", " (", "options", ".scene == ", "1007", " || ", "options", ".scene == ", "1008", " || ", "options", ".scene == ", "1044", ") {\r\n      livePlayer.getShareParams().then(", "res", " =>", " {\r\n          ", "console", ".", "log", "(", "'get room id'", ", ", "res", ".room_id) ", "// 房间号", "\r\n          ", "console", ".", "log", "(", "'get openid'", ", ", "res", ".openid) ", "// 用户openid", "\r\n          ", "console", ".", "log", "(", "'get share openid'", ", ", "res", ".share_openid) ", "// 分享者openid", "\r\n          ", "console", ".", "log", "(", "'get custom params'", ", ", "res", ".custom_params) ", "// 自定义参数", "\r\n      }).", "catch", "(", "err", " =>", " {\r\n          ", "console", ".", "log", "(", "'get share params'", ", err)\r\n      })\r\n  }\r\n}\r\n复制代码", "可以收集进入直播间的用户以及分享者的信息", "7.其它途径进入直播间", "直播间", "小程序", "码", "// type=9 小程序码", "\r\n", "\"plugin-private://wx2b03c6e691cd7370/pages/live-player-plugin?room_id=[直播房间id]&type=9\"", "\r\n\r\n", "// 添加自定义参数 custom_params", "\r\n", "\"...&custom_params=encodeURIComponent(JSON.stringify(custom_params))\"", "\r\n复制代码", "公众号小卡片", "// type=10 小卡片", "\r\n", "\"plugin-private://wx2b03c6e691cd7370/pages/live-player-plugin?room_id=[直播房间id]&type=10\"", "\r\n\r\n", "// 添加自定义参数 custom_params", "\r\n", "\"...&custom_params=encodeURIComponent(JSON.stringify(custom_params))\"", "\r\n复制代码", " "]}
{"title": "小程序页面间传递数据 ", "author": "Rolan", "pub_time": "2020-5-22 00:28", "content": [" \n                     \n                    ", "最近在做", "小程序", "项目，发现小程序的页面间经常需要传递一些数据。根据自己的了解和熟悉，针对不同的数据要求，总结到有几种不同的传数据方式，下面做一下简单的介绍归纳。", "\r\n", "第一种：页面跳转时通过url传递", "\r\n", "使用", "wx.navigateTo", " 与 ", "wx.redirectTo", " 的时候，可以将部分数据放在 url 里面，并在新页面 ", "onLoad", " 的时候获取且初始化。", "\r\n", "//pageA.js", "\r\n\r\n", "// Navigate", "\r\nwx", ".", "navigateTo", "(", "{", "\r\n  url", ":", " ", "'../pageB/pageB?name=lin&gender=male'", ",", "\r\n", "}", ")", "\r\n\r\n", "// Redirect", "\r\nwx", ".", "redirectTo", "(", "{", "\r\n  url", ":", " ", "'../pageB/pageB?name=lin&gender=male'", ",", "\r\n", "}", ")", "\r\n\r\n", "// pageB.js", "\r\n", "...", "\r\n", "Page", "(", "{", "\r\n  ", "onLoad", ":", " ", "function", "(", "option", ")", "{", "\r\n    console", ".", "log", "(", "option", ".", "name ", "+", " ", "'is'", " ", "+", " option", ".", "gender", ")", ";", "\r\n    ", "this", ".", "setData", "(", "{", "\r\n      option", ":", " option\r\n    ", "}", ")", ";", "\r\n  ", "}", "\r\n", "}", ")", "\r\n", "\r\n", "需要注意的问题：", "\r\n", "\r\n", "使用", "wx.navigateTo", " 与 ", "wx.redirectTo", "时，不允许跳转到 tab 所包含的页面；", "\r\n", "\r\n", "onLoad", "只执行一次；", "\r\n", "\r\n", "适用：", "\r\n这种方式一般适用于少数页面之间需要少量数据传递，如B页面需要A页面中的1-2个数据等等。", "\r\n", "第二种：使用全局变量来传递", "\r\n", "在 app.js 文件中定义全局变量 ", "globalData", "，旧页面将要传递的数据赋值存放在里面，新页面调用全局变量获取传递数据值。", "\r\n", "// app.js", "\r\n\r\n", "App", "(", "{", "\r\n     ", "// 全局变量", "\r\n  globalData", ":", " ", "{", "\r\n    name", ":", " ", "null", "\r\n  ", "}", "\r\n", "}", ")", "\r\n\r\n", "//pageA.js", "\r\n···\r\n", "getApp", "(", ")", ".", "globalData", ".", "name ", "=", " ", "\"lin\"", ";", "\r\n\r\n\r\n", "//pageB.js", "\r\n···\r\n", "this", ".", "setData", "(", "{", "\r\n  userName", ":", " ", "getApp", "(", ")", ".", "globalData", ".", "name\r\n", "}", ")", ";", "\r\n", "\r\n", "要注意的问题：", "\r\n", "\r\n", "使用的时候，直接使用 ", "getApp()", " 拿到存储的信息。", "\r\n", "\r\n", "适用：", "\r\n这种方式一般适用于多个页面或者全部页面都需要获取使用同一个数据，比如一开始进入首页就获取到的用户信息等；", "\r\n", "第三种：使用本地缓存", "\r\n", "使用小程序中的本地缓存", "Storage", "，旧页面将传递数据存入缓存中，新页面通过调用获取缓存的API得到数据。", "\r\n", "//pageA.js", "\r\n···\r\nwx", ".", "setStorageSync", "(", "'sessionId'", ",", " res", ".", "sessionId", ")", ";", "\r\n\r\n\r\n", "//pageB.js", "\r\n···\r\n", "var", " sessionId ", "=", " wx", ".", "getStorageSync", "(", "'sessionId'", ")", ";", "\r\n", "\r\n", "要注意的问题：", "\r\n", "\r\n", "Storage每次存入会覆盖掉原来该 key 对应的内容。", "\r\n", "如果用户主动删除小程序或因存储空间原因被系统清理，Storage中数据将被清除。", "\r\n", "单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。", "\r\n", "\r\n", "适用：", "\r\n这种方式一般适用于即使小程序退出然后再重新进入，也要保留的数据，类似于登录状态的保留等。", " "]}
{"title": "倒计时组件实现代码 ", "author": "Rolan", "pub_time": "2020-5-29 00:11", "content": [" \n                     \n                    ", "功能: 适用于电商应用的限时团购、商品秒杀等", "先来看下最终效果：", "git源：http://git.oschina.net/dotton/CountDown", "分步骤-性子急的朋友，可以直接看最后那段代码。", "wxml文件放个text", "<text>second: {{second}} micro second:{{micro_second}}</text>", "在js文件中调用", "function countdown(that) {\r\n var second = that.data.second\r\n if (second == 0) {\r\n  // console.log(\"Time Out...\");\r\n  that.setData({\r\n   second: \"Time Out...\"\r\n  });\r\n  return ;\r\n }\r\n var time = setTimeout(function(){\r\n  that.setData({\r\n   second: second - 1\r\n  });\r\n  countdown(that);\r\n }\r\n ,1000)\r\n}\r\n\r\nPage({\r\n  data: {\r\n    second: 3\r\n  },\r\n  onLoad: function() {\r\n    countdown(this);\r\n  }\r\n});\r\n", "运行验证下，从10走到1s，然后显示时间到。", "于是继续将毫秒完善，注意毫秒的步长受限于系统的时间频率，于是我们精确到0.01s即10ms", "js", "/* 秒级倒计时 */\r\nfunction countdown(that) {\r\n var second = that.data.second\r\n if (second == 0) {\r\n  that.setData({\r\n   second: \"Time out!\",\r\n   micro_second: \"micro_second too.\"\r\n  });\r\n  clearTimeout(micro_timer);\r\n  return ;\r\n }\r\n var timer = setTimeout(function(){\r\n  that.setData({\r\n   second: second - 1\r\n  });\r\n  countdown(that);\r\n }\r\n ,1000)\r\n}\r\n\r\n/* 毫秒级倒计时 */\r\n// 初始毫秒数，同时用作归零\r\nvar micro_second_init = 100;\r\n// 当前毫秒数\r\nvar micro_second_current = micro_second_init;\r\n// 毫秒计时器\r\nvar micro_timer;\r\n\r\nfunction countdown4micro(that) {\r\n if (micro_second_current <= 0) {\r\n  micro_second_current = micro_second_init;\r\n }\r\n micro_timer = setTimeout(function(){\r\n  that.setData({\r\n   micro_second: micro_second_current - 1\r\n  });\r\n  micro_second_current--;\r\n  countdown4micro(that);\r\n }\r\n ,10)\r\n}\r\n\r\nPage({\r\n  data: {\r\n    second: 2,\r\n    micro_second: micro_second_init\r\n  },\r\n  onLoad: function() {\r\n    countdown(this);\r\n    countdown4micro(this);\r\n  }\r\n});\r\n", "wxml文件", "<text style=\"display: block;\">second: {{second}}s</text>\r\n\r\n<text>{{micro_second}}</text>\r\n", "如此，当秒级运行完毕时，毫秒级timer即clearTimeout，并将字本显示为'micro_second too'", "再添加一个countdown4micro方法，使得显示剩余 0:3:19 89这样形式的倒数", "function dateformat(second) {\r\n  var dateStr = \"\";\r\n  var hr = Math.floor(second / 3600);\r\n  var min = Math.floor((second - hr * 3600) / 60);\r\n  var sec = (second - hr * 3600 - min * 60);// equal to => var sec = second % 60;\r\n  dateStr = hr + \":\" + min + \":\" + sec;\r\n  return dateStr;\r\n}\r\n目前有2个时钟，影响性能，合并下去掉countdown，于是countdown4micro变成以下的样子：\r\n\r\nfunction countdown4micro(that) {\r\n\r\n  var loop_second = Math.floor(loop_index / 100);\r\n  // 得知经历了1s\r\n  if (cost_micro_second != loop_second) {\r\n    // 赋予新值\r\n    cost_micro_second = loop_second;\r\n    // 总秒数减1\r\n    total_second--;\r\n\r\n  }\r\n   // 每隔一秒，显示值减1; 渲染倒计时时钟\r\n  that.setData({\r\n   clock:dateformat(total_second - 1)\r\n  });\r\n\r\n   if (total_second == 0) {\r\n    that.setData({\r\n     // micro_second: \"\",\r\n     clock:\"时间到\"\r\n    });\r\n    clearTimeout(micro_timer);\r\n    return ;\r\n   }  \r\n\r\n if (micro_second_current <= 0) {\r\n  micro_second_current = micro_second_init;\r\n }\r\n micro_timer = setTimeout(function(){\r\n  that.setData({\r\n   micro_second: micro_second_current - 1\r\n  });\r\n  micro_second_current--;\r\n  // 放在最后++，不然时钟停止时还有10毫秒剩余\r\n  loop_index ++;\r\n  countdown4micro(that);\r\n }\r\n ,10)\r\n}\r\n", "如此这般，毫秒与时分秒是分别运行渲染的，再次改造，程序可读性更好。dateformat针对于毫秒操作，而不接受秒为数。同时还省却了计算100次为1s的运算", "/**\r\n * 需要一个目标日期，初始化时，先得出到当前时间还有剩余多少秒\r\n * 1.将秒数换成格式化输出为XX天XX小时XX分钟XX秒 XX\r\n * 2.提供一个时钟，每10ms运行一次，渲染时钟，再总ms数自减10\r\n * 3.剩余的秒次为零时，return，给出tips提示说，已经截止\r\n */\r\n\r\n// 定义一个总毫秒数，以一分钟为例。TODO，传入一个时间点，转换成总毫秒数\r\nvar total_micro_second = 2 * 1000;\r\n\r\n/* 毫秒级倒计时 */\r\nfunction countdown(that) {\r\n   // 渲染倒计时时钟\r\n   that.setData({\r\n     clock:dateformat(total_micro_second)\r\n   });\r\n\r\n   if (total_micro_second <= 0) {\r\n     that.setData({\r\n       clock:\"已经截止\"\r\n     });\r\n     // timeout则跳出递归\r\n     return ;\r\n   }\r\n   setTimeout(function(){\r\n    // 放在最后--\r\n    total_micro_second -= 10;\r\n    countdown(that);\r\n  }\r\n  ,10)\r\n}\r\n\r\n// 时间格式化输出，如3:25:19 86。每10ms都会调用一次\r\nfunction dateformat(micro_second) {\r\n   // 秒数\r\n   var second = Math.floor(micro_second / 1000);\r\n   // 小时位\r\n   var hr = Math.floor(second / 3600);\r\n   // 分钟位\r\n   var min = Math.floor((second - hr * 3600) / 60);\r\n   // 秒位\r\n  var sec = (second - hr * 3600 - min * 60);// equal to => var sec = second % 60;\r\n  // 毫秒位，保留2位\r\n  var micro_sec = Math.floor((micro_second % 1000) / 10);\r\n  return hr + \":\" + min + \":\" + sec + \" \" + micro_sec;\r\n}\r\n\r\nPage({\r\n  data: {\r\n    clock: ''\r\n  },\r\n  onLoad: function() {\r\n    countdown(this);\r\n  }\r\n});\r\n", "经过如上优化，代码量减少一半，运行效率也高了。", "感谢阅读，希望能帮助到大家，谢谢大家对本站的支持！", " "]}
{"title": "taro 实现购物车逻辑的实例代码 ", "author": "Rolan", "pub_time": "2020-6-8 00:31", "content": [" \n                     \n                    ", "效果", "taro是什么？", "Taro 是一套遵循 React 语法规范的 多端开发 解决方案。", "现如今市面上端的形态多种多样，Web、React-Native、微信", "小程序", "等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。", "使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ/京东小程序、快应用、H5、React-Native 等）运行的代码。本代码是基于Taro UI 开发的，虽然是基于 taro框架开发的，但购物车的整体逻辑与微信小程序逻辑是基本一样的", "Taro UI是一款基于 Taro 框架开发的多端 UI 组件库", "需要安装taro ui", "$ npm ", "install", " taro-ui\r\n", "taro官方文档", "taroUI 官方文档", "cart/index.jsx页面代码\r\n", "import", " Taro, { Component } from ", "'@tarojs/taro'", "\r\n", "import", " { View, Checkbox, CheckboxGroup } from ", "'@tarojs/components'", "\r\n", "//用到了taro的三个组件", "\r\n", "//想了解可以去查看taro的官方文档", "\r\n", "import", " ", "'./index.scss'", "\r\n", "import", " { AtButton, AtInputNumber, AtCard } from ", "'taro-ui'", "\r\n", "import", " { request, toast } from ", "'../../utils/index'", "\r\n\r\n", "class", " ", "Index", " ", "extends", " ", "Component", " ", "{\r\n ", "constructor", "(props) {\r\n  ", "super", "(props)\r\n  ", "this", ".state = {\r\n   message: ", "''", ", ", "//购物车为空时显示的信息", "\r\n   cartdata: [], ", "//购物车的数据列表", "\r\n   isactive: ", "false", ", ", "//全选按钮是否选中", "\r\n   check:", "false", ", ", "//单个商品购物车是否被选中", "\r\n   totalnum:", "0", ", ", "//总数量", "\r\n   totalprice:", "0", ", ", "//总价格", "\r\n   activedata:[] ", "//复选框选中的数据列表", "\r\n  }\r\n\r\n }\r\n componentDidShow () {\r\n  ", "//获取购物车数据", "\r\n  ", "try", " {\r\n   const token = Taro.getStorageSync(", "'token'", ") ", "//这两个数据是我在登录页面，登录时添加到本地的token和用户id", "\r\n   const userid = Taro.getStorageSync(", "'userid'", ")\r\n   ", "if", " (token) { ", "//如果登录了", "\r\n    const usrename = Taro.getStorageSync(", "'username'", ") ", "//同样登录时添加到本地的用户名", "\r\n    Taro.setNavigationBarTitle({ ", "//改变导航栏的标题", "\r\n     title: usrename + ", "'---购物车'", "\r\n    })\r\n    request({ ", "//这里的request是封装后的方法", "\r\n     url: ", "'/cart'", ", ", "//接口", "\r\n     ", "data", ": { ", "//需要传递的数据", "\r\n      token,\r\n      userid\r\n     }\r\n    }).then(res => {\r\n     console.log(res.", "data", ")\r\n     const { code } = res.", "data", "\r\n     ", "if", " (code === ", "'10119'", ") { ", "//后端返回的值 ，判断状态", "\r\n      toast({ title: ", "'登录已经过期，请从新登录'", " })\r\n      Taro.navigateTo({  ", "//跳转到登录页", "\r\n       url: ", "'/pages/login/index'", "\r\n      })\r\n     } ", "else", " ", "if", " (code === ", "'10012'", ") {\r\n      ", "this", ".setState({\r\n       message: ", "'购物车空空如也'", "\r\n      })\r\n     } ", "else", " {\r\n     ", "//因为taro是基于react的，在react中，状态不能直接改变，要用this.setState", "\r\n      ", "this", ".setState({ ", "//登录成功，购物车有数据时，将购物车的列表数据添加到购物车数据中", "\r\n       cartdata: res.", "data", ".", "data", "\r\n      })\r\n     }\r\n    })\r\n   } ", "else", " { ", "//如果没登录", "\r\n    toast({ title: ", "'请登录'", " })\r\n    Taro.navigateTo({ ", "//跳转到登录页面", "\r\n     url: ", "'/pages/login/index'", "\r\n    })\r\n   }\r\n\r\n  } ", "catch", " (e) {\r\n\r\n  }\r\n }\r\n componentDidUpdate(){\r\n  ", "//计算总数量，总价格", "\r\n  let num=", "0", ";\r\n  let price=", "0", ";\r\n  ", "if", "(", "this", ".state.activedata.length!=", "0", "){ ", "//如果选中的数组长度不为0时，就是有商品被选中了", "\r\n   ", "this", ".state.activedata.map((item)=>{ ", "//map遍历数组", "\r\n    num+= +item.num  ", "//将数量相加 + 号为一元运算符，将字符串类型转换为数值类型", "\r\n    price+=item.num*item.price  ", "//求价格", "\r\n   })\r\n   ", "this", ".setState({ ", "//设置值", "\r\n    totalnum:num,\r\n    totalprice:price\r\n   })\r\n  }", "else", "{ ", "//如果没有商品被选中", "\r\n   ", "this", ".setState({\r\n    totalnum:", "0", ",\r\n    totalprice:", "0", "\r\n   })\r\n  }\r\n\r\n }\r\n render() {\r\n  ", "return", " ( ", "//结构开始", "\r\n   <View>{\r\n    ", "this", ".state.message.length === ", "0", " ? ", "null", " : ", "//如果 message不为空的话，就代表着购物车没有数据，所以显示购物车空空如也，去选购，如果为空，代表着购物车有数据，不显示", "\r\n     <View onClick={() => { ", "//点击事件 去主页选购商品", "\r\n      Taro.switchTab({\r\n       url: ", "'/pages/home/index'", "\r\n      })\r\n     }}> {", "this", ".state.message}去选购</View>\r\n   }\r\n    <Checkbox checked={", "this", ".state.isactive} onClick={()=>{ ", "//全选按钮 check代表着按钮是否选中 因为taro中的checkbox的onchange方法，不支持小程序，所以没办法，只能用 onClick方法", "\r\n     let active=!", "this", ".state.isactive   ", "//实现点击选中状态取反", "\r\n     ", "this", ".setState({\r\n      isactive:active\r\n     })\r\n     ", "if", "(active===", "true", "){ ", "//如果全选，就代表着 购物车的所有商品都被选中，所以，将购物车列表数据全给选中的数组，将单个商品的状态全部设为选中", "\r\n      ", "this", ".setState({\r\n       check:", "true", ",\r\n       activedata:", "this", ".state.cartdata\r\n      })\r\n     }", "else", "{", "//否则，选中商品数组为空，将单个商品的状态全部设为未选中", "\r\n      ", "this", ".setState({\r\n       check:", "false", ",\r\n       activedata:[]\r\n      })\r\n     }\r\n    }}>全选</Checkbox>\r\n\r\n    <CheckboxGroup  onChange={(evt)=>{ ", "//复选框组，<CheckboxGroup/>中选中项发生改变是触发 change 事件，detail = value:[选中的 Checkbox 的 value 的数组]", "\r\n     const {detail:{value}}=evt\r\n     ", "if", "(value.length===", "this", ".state.cartdata.length){ ", "//选中的数组的长度如果等于购物车列表的长度是全选", "\r\n      ", "this", ".setState({\r\n       isactive:", "true", ",  ", "//全选按钮被选中", "\r\n       activedata:", "this", ".state.cartdata  ", "//选中商品数组为购物车的列表数组", "\r\n      })\r\n     }", "else", "{ ", "//否则未全选", "\r\n      ", "var", " i;\r\n      ", "var", " ", "data", "=[];\r\n      ", "for", " ( i ", "in", " value){  ", "//因为value数组里的值为选中的checkbox的value的值，我设置的为cartid", "\r\n       ", "data", ".push(...(", "this", ".state.cartdata.filter(item=>{ ", "//过滤下购物车的列表数据，将cartid相等的对象取出来，放进data数组中，...是展开运算符，加他是因为在控制台打印的时候发现，每个对象外面都加了一个【】，没办法，这里应该是有简单的写法的，但因为当时累了，也没有细想，就只能写成这样了，", "\r\n        ", "return", " item.cartid==value[i]\r\n       })))\r\n      }\r\n      console.log(", "data", ",", "this", ".state.cartdata)\r\n      ", "this", ".setState({\r\n       isactive:", "false", ",", "//全选按钮未被选中", "\r\n       activedata:", "data", " ", "//设置选中商品的数组", "\r\n       ", "//至此，计算总数量，总价格、全选、单选的逻辑就全完成了，至于为什么写成这样，是因为taro是基于react的标准的，没有计算属性，没有双向绑定", "\r\n      })\r\n     }\r\n    }}>\r\n     {\r\n      ", "this", ".state.cartdata.map((item, index) => ", "//循环显示购物车数据", "\r\n       <AtCard\r\n        title={item.proname}\r\n        thumb={item.proimg}\r\n        extra={", "'$'", "+item.price}\r\n        key={item.proid}\r\n\r\n       >\r\n        <View><Checkbox value={item.cartid} checked={", "this", ".state.check}></Checkbox>\r\n        {", "/* 每个商品前的复选框 */", "}\r\n         <AtInputNumber ", "//数量加减", "\r\n          min={", "0", "}\r\n          max={", "10", "}\r\n          step={", "1", "}\r\n          value={item.num} ", "//之间的值", "\r\n          onChange={", "this", ".change.bind(", "this", ", item,index)} ", "//onchange输入框值改变时触发的事件，开发者需要通过 onChange 事件来更新 value 值变化，onChange 函数必填", "\r\n         />\r\n         <AtButton type=", "'primary'", " size=", "'small'", " onClick={", "this", ".del.bind(", "this", ",item)}>删除</AtButton>\r\n         {", "/* 删除按钮 */", "}\r\n        </View>\r\n\r\n       </AtCard>\r\n      )\r\n     }\r\n    </CheckboxGroup>\r\n    <View>总数量：{", "this", ".state.totalnum}</View>\r\n    <View>总价格：{", "this", ".state.totalprice}</View>\r\n   </View>\r\n  )\r\n }\r\n del(item){ ", "//删除方法", "\r\n ", "//item代表着商品的数据", "\r\n  ", "try", "{\r\n   const token = Taro.getStorageSync(", "'token'", ")\r\n   ", "if", "(token){ ", "//如果有token值", "\r\n    request({ ", "//数据请求   删除接口", "\r\n     url: ", "'/cart/delete'", ",\r\n     ", "data", ": {\r\n      token,\r\n      cartid: item.cartid\r\n     }\r\n    }).then(res => {\r\n     const { code } = res.", "data", "\r\n     ", "if", " (code === ", "'10119'", ") { ", "//后端接口 返回值", "\r\n      toast({ title: ", "'登录状态过期，请重新登录'", " })\r\n      Taro.navigateTo({  ", "//跳转到登录页面", "\r\n       url: ", "'/pages/login/index'", "\r\n      })\r\n     }", "else", "{\r\n       toast({title:", "'删除成功!'", "}) ", "//显示提示框 封装的一个方法 其实到这步，商品就已经删除了，但页面还没有发生变化，所以我们要处理下页面", "\r\n       let id=item.cartid\r\n       let data1=", "this", ".state.cartdata.filter(item=>{ ", "//过滤下不等于被删除的商品id，将未删除的商品，放到data1中", "\r\n        ", "return", " item.cartid!=id\r\n       })\r\n       let data2=", "this", ".state.activedata.filter(item=>{ ", "//在选中情况下", "\r\n        ", "return", " item.cartid!=id\r\n       })\r\n       ", "this", ".setState({ ", "//设置下购物车列表数据", "\r\n        cartdata:data1,\r\n        activedata:data2\r\n       })\r\n     }\r\n    })\r\n   }", "else", "{ ", "//如果没有token值", "\r\n    toast({ title: ", "'请登录'", " })\r\n    Taro.navigateTo({ ", "//跳转到登录页面", "\r\n     url: ", "'/pages/login/index'", "\r\n    })\r\n   }\r\n  }", "catch", "(e){\r\n\r\n  }\r\n }\r\n change(item,index,evt) {\r\n  ", "//数量改变", "\r\n  console.log(evt)\r\n  ", "//item代表着商品的数据", "\r\n  ", "//index，为当前改变的是那个商品的值，", "\r\n  ", "//evt为改变后的数值", "\r\n  ", "try", " {\r\n   const token = Taro.getStorageSync(", "'token'", ")\r\n   ", "if", " (token) { ", "//如果有token值", "\r\n    ", "if", " (evt === ", "'0'", ") { ", "//数量为0 我设置的为删除商品，与上面的删除一致，这里我就不再解释了", "\r\n     request({\r\n      url: ", "'/cart/delete'", ",\r\n      ", "data", ": {\r\n       token,\r\n       cartid: item.cartid\r\n      }\r\n     }).then(res => {\r\n      const { code } = res.", "data", "\r\n      ", "if", " (code === ", "'10119'", ") {\r\n       toast({ title: ", "'登录状态过期，请重新登录'", " })\r\n       Taro.navigateTo({\r\n        url: ", "'/pages/login/index'", "\r\n       })\r\n      }", "else", "{\r\n        toast({title:", "'删除成功!'", "})\r\n        let id=item.cartid\r\n        let data1=", "this", ".state.cartdata.filter(item=>{\r\n         ", "return", " item.cartid!=id\r\n        })\r\n        let data2=", "this", ".state.activedata.filter(item=>{ ", "//在选中情况下", "\r\n        ", "return", " item.cartid!=id\r\n       })\r\n        ", "this", ".setState({\r\n         cartdata:data1,\r\n         activedata:data2\r\n        })\r\n\r\n      }\r\n     })\r\n    }", "else", "{ ", "//改变的值不为0 ，", "\r\n     request({\r\n      url: ", "'/cart/update'", ", ", "//更新接口", "\r\n      ", "data", ": {\r\n       token,\r\n       cartid: item.cartid,\r\n       num:evt  ", "//将改变的值直接付给num", "\r\n      }\r\n     }).then(res => {\r\n      const { code } = res.", "data", "\r\n      ", "if", " (code === ", "'10119'", ") {  ", "//后端验证", "\r\n       toast({ title: ", "'登录状态过期，请重新登录'", " })\r\n       Taro.navigateTo({ ", "//跳转到登录页", "\r\n        url: ", "'/pages/login/index'", "\r\n       })\r\n      }", "else", "{\r\n        toast({title:", "'更新成功!'", "})\r\n        item.num=evt ", "//改变下数量", "\r\n       ", "// var newitem=item", "\r\n       ", "// var data=this.state.cartdata.map(item=>{", "\r\n       ", "//  return item.cartid===newitem.cartid ?newitem :item", "\r\n       ", "// })", "\r\n       ", "var", " ", "data", "=", "this", ".state.cartdata ", "//将购物车里边数据赋给data ，因为在react中，状态不能直接改变", "\r\n       ", "data", "[index]=item ", "// 将新的对象赋给数组的第index对象", "\r\n       ", "this", ".setState({ ", "//设置下", "\r\n        cartdata:", "data", "\r\n       })\r\n      }\r\n     })\r\n    }\r\n   } ", "else", " {", "//如果没有token值", "\r\n    toast({ title: ", "'请登录'", " })\r\n    Taro.navigateTo({\r\n     url: ", "'/pages/login/index'", "\r\n    })\r\n   }\r\n\r\n  } ", "catch", " (e) {\r\n\r\n  }\r\n\r\n }\r\n}\r\n\r\nexport ", "default", " Index", "cart/index.scss页面代码\r\n@", "import", " ", "\"~taro-ui/dist/style/components/card.scss\"", ";\r\n@", "import", " ", "\"~taro-ui/dist/style/components/button.scss\"", ";\r\n@", "import", " ", "\"~taro-ui/dist/style/components/loading.scss\"", ";\r\n@", "import", " ", "\"~taro-ui/dist/style/components/icon.scss\"", ";\r\n@", "import", " ", "\"~taro-ui/dist/style/components/input-number.scss\"", ";", "utils/index.js代码\r\n", "const", " publicurl =", "''", "，", "//接口就不放上去了，因为也不是我的，这里就放接口前的公共网址", "\r\n", "import", " Taro ", "from", " ", "'@tarojs/taro'", "\r\n", "export", " ", "function", " ", "request", "(", "options", ")", "{\r\n ", "const", " {url,data,method}=options\r\n wx.showLoading({ ", "//显示loading框", "\r\n  title: ", "'加载中'", ",\r\n })\r\n ", "return", " ", "new", " ", "Promise", "(", "(", "resolve,reject", ")=>", "{\r\n  Taro.request({ ", "//数据请求 与小程序类似", "\r\n   url: publicurl+url,\r\n   ", "data", ":data || {},\r\n   ", "method", ":method || ", "'GET'", ",\r\n   success(res){\r\n    ", "//成功", "\r\n    resolve(res)\r\n   },\r\n   fail(err){\r\n    ", "//失败", "\r\n    reject(err)\r\n   },\r\n   complete(){\r\n    ", "// complete 接口调用结束的回调函数", "\r\n    wx.hideLoading(); ", "//隐藏loading框", "\r\n   }\r\n  })\r\n })\r\n}\r\n\r\n", "export", " ", "function", " ", "toast", "(", "options", ")", "{\r\n  ", "const", " {title,icon, duration}=options\r\n  Taro.showToast({\r\n   title,\r\n   ", "icon", ": icon || ", "'none'", ",\r\n   ", "duration", ":duration || ", "1000", "\r\n  })\r\n}", "总结", "到此这篇关于taro 实现购物车逻辑的实例代码的文章就介绍到这了,更多相关taro 购物车逻辑内容请搜索我们以前的文章或继续浏览下面的相关文章希望大家以后多多支持我们！", " "]}
{"title": "小程序调用百度api天气接口 ", "author": "Rolan", "pub_time": "2020-6-12 00:55", "content": [" \n                     \n                    ", "百度接口申请AK ", "http://lbsyun.baidu.com/apiconsole/key", "配置服务器合法域名", "在demo中修改自己的AK", "// 引用百度地图微信", "小程序", "JSAPI模块 ", "var", " bmap ", "=", " ", "require", "(", "'../../libs/bmap-wx.js'", ");", " ", "Page", "({", " ", "    data", ":", " ", "{", " ", "        weatherData", ":", " ", "''", " ", "    ", "},", " ", "    onLoad", ":", " ", "function", "()", " ", "{", " ", "        ", "var", " that ", "=", " ", "this", ";", " ", "        ", "// 新建百度地图对象 ", "        ", "var", " ", "BMap", " ", "=", " ", "new", " bmap", ".", "BMapWX", "({", " ", "            ak", ":", " ", "'修改为自己的ak'", " ", "        ", "});", " ", "        ", "var", " fail ", "=", " ", "function", "(", "data", ")", " ", "{", " ", "            console", ".", "log", "(", "data", ")", " ", "        ", "};", " ", "        ", "var", " success ", "=", " ", "function", "(", "data", ")", " ", "{", " ", "            ", "var", " weatherData ", "=", " data", ".", "currentWeather", "[", "0", "];", " ", "            weatherData ", "=", " ", "'城市：'", " ", "+", " weatherData", ".", "currentCity ", "+", " ", "'\\n'", " ", "+", " ", "'PM2.5：'", " ", "+", " weatherData", ".", "pm25 ", "+", " ", "'\\n'", " ", "+", "'日期：'", " ", "+", " weatherData", ".", "date ", "+", " ", "'\\n'", " ", "+", " ", "'温度：'", " ", "+", " weatherData", ".", "temperature ", "+", " ", "'\\n'", " ", "+", "'天气：'", " ", "+", " weatherData", ".", "weatherDesc ", "+", " ", "'\\n'", " ", "+", "'风力：'", " ", "+", " weatherData", ".", "wind ", "+", " ", "'\\n'", ";", " ", "            that", ".", "setData", "({", " ", "                weatherData", ":", " weatherData ", "            ", "});", " ", "        ", "}", " ", "        ", "// 发起weather请求 ", "        ", "BMap", ".", "weather", "({", " ", "            fail", ":", " fail", ",", " ", "            success", ":", " success ", "        ", "});", " ", "    ", "}", " ", "})", "注意：demo中改动", "var fail = function(data) { console.log(data) };", "如果调用失败会出现报错信息，按照以上步骤检查一遍，就调用成功了。", "\r\n", "\r\n", "另外demo中有weather天气查询之外还有：", "\r\n", "\r\n", "\r\n", "\r\n", "PIO检索search------例如：检索周边饭店", "PIO检索热词联想suggestion------就是关键词搜索", "逆地址解析regeocoding------可以理解为定位", " "]}
{"title": "从零开始的微信小程序（记录学习的过程） ", "author": "Rolan", "pub_time": "2020-6-15 00:06", "content": [" \n                     \n                    ", "首先跟着官网顺一遍文档，对", "小程序", "框架、插件、基础能力和文件有个最基本的了解，这里写一下开始时遇到的一些问题。", "\r\n", "1、小程序开发者工具提示没找到可以构建的npm包", "\r\n", "  解决方案\r\n  1、第一步：npm init（一定要进行初始化，生成package.json文件）\r\n  2、第二步：npm install --production\r\n  3、第三步：npm i vant-weapp -S --production ）（这里开始用的是vant-weapp，需要别的可以按照自己的需求选择）\r\n  4、勾选使用npm模块\r\n", "复制代码", "\r\n", "\r\n", "2、版本管理", "\r\n", "    1、版本管理 > 设置 > 通用 > 用户 中修改成自己码云中账号和密码\r\n    2、网络和认证中 使用用户名和密码认证\r\n    3、远程中添加自己的git地址（这里用的码云管理的项目）\r\n", "复制代码", "\r\n", "\r\n3、文件类型\r\n", "\r\n4、基本结构", "\r\n", "    app.json 全局配置文件\r\n    app.wxss 全局样式文件\r\n", "复制代码", "\r\n", " "]}
{"title": "小程序直播总结 ", "author": "Rolan", "pub_time": "2020-6-15 00:33", "content": [" \n                     \n                    ", "内嵌腾讯直播H5：腾讯直播已改名NOW直播，", "小程序", "接入工具文档无法找到", "小程序原生实现：小程序对直播和 ", "websocket", " 都进行了比较好的封装，通过 ", "live-pusher", " ", "live-player", " 组件和 ", "websocket API", " 即可实现直播互动功能", "接入小程序直播插件实现：小程序直播，是微信提供给小程序开发者的直播组件。", "二、小程序原生实现直播功能流程", "微信小程序从 ", "1.7", " 开始，为开发者提供了两个新接口， ", "<live-pusher>", " 和 ", "<live-player>", " ，可以在小程序上实现单向的直播功能。通过与技术的结合，比如 ", "WebRTC", " ，开发者们还可以进一步在小程序直播的基础上实现连麦功能", "首先由于微信对小程序直播功能类目有限制，限定了特定类目的小程序使用", "另外需要注意的两点：", "个人号无法申请使用直播功能；", "社交类目开通直播功能需要相关视频许可和文网文资质许可；", "所以小程序开通直播的业务，要根据产品的目的和场景去申请对应的类目。", "在小程序管理后台，「开发」-「接口设置」中自助开通对应的权限，如下图所示：", "微信小程序原生实现直播功能流程如上图所示，录制端小程序通过 ", "[live-pusher]", " 组件对手机和麦克风的数据进行采集和编码推流到服务器，服务器端对数据进行加工处理并分发给多个客户端，播放端小程序通过 ", "[live-player]", " 组件从云端拉流并进行实时无差异的解码和渲染，从而实现直播小程序完整互动功能", "1. 推流 API 调用流程图", "2. 拉流 API 调用流程图", "三、小程序直播实现过程", "微信小程序中的推拉流功能，需要用到微信提供的 ", "live-player", " ", "live-pusher", " 标签", "3.1 live-player", "live-player", " 是微信提供的支持实时音视频播放的组件， ", "官方介绍详见组件介绍", " 。", "创建 live-player 的演示源码如下", "<", "live-player", "\r\n    ", "autoplay", "\r\n    ", "wx:if", "=", "\"", "{{item.playUrl}", "}\"", "\r\n    ", "id", "=", "\"", "{{item.streamID}", "}\"", "\r\n    ", "mode", "=", "\"RTC\"", "\r\n    ", "object-fit", "=", "\"fillCrop\"", "\r\n    ", "min-cache", "=", "\"0.1\"", "\r\n    ", "max-cache", "=", "\"0.3\"", "\r\n    ", "src", "=", "\"", "{{item.playUrl}", "}\"", "\r\n    ", "debug", "=", "\"", "{{pushConfig.showLog}", "}\"", "\r\n    ", "bindstatechange", "=", "\"onPlayStateChange\"", "\r\n    ", "bindnetstatus", "=", "\"onPlayNetStateChange\"", "\r\n    ", "binderror", "=", "\"error\"", ">", "\r\n    ", "<", "cover-view", " ", "class", "=", "'character'", " ", "style", "=", "'padding: 0 5px;'", ">", "{{item.streamID}", "}", "</", "cover-view", ">", "\r\n", "</", "live-player", ">", "\r\n", "请注意", "live", " 模式主要用于直播类场景，比如赛事直播、在线教育、远程培训等等。该模式下，小程序内部的模块会优先保证观看体验的流畅，通过调整 ", "min-cache", " 和 ", "max-cache", " 属性，您可以调节观众(播放)端所感受到的时间延迟的大小，文档下面会详细介绍这两个参数", "RTC", " 则主要用于双向视频通话或多人视频通话场景，比如金融开会、在线客服、车险定损、培训会议 等等。在此模式下，对 ", "min-cache", " 和 ", "max-cache", " 的设置不会起作用，因为小程序内部会自动将延迟控制在一个很低的水平( ", "500ms", " 左右)。", "3.2 live-pusher", "live-pusher 是微信提供的支持实时音视频录制的组件， ", "官方介绍详见：组件介绍", "创建 ", "live-pusher", " 的演示源码如下", "<", "live-pusher", "\r\n    ", "wx:if", "=", "\"", "{{pushUrl}", "}\"", "\r\n    ", "id", "=", "\"video-livePusher\"", "\r\n    ", "mode", "=", "\"RTC\"", "\r\n    ", "url", "=", "\"", "{{pushUrl}", "}\"", "\r\n    ", "min-bitrate", "=", "\"", "{{pushConfig.minBitrate}", "}\"", "\r\n    ", "max-bitrate", "=", "\"", "{{pushConfig.maxBitrate}", "}\"", "\r\n    ", "aspect", "=", "\"", "{{pushConfig.aspect}", "}\"", "\r\n    ", "beauty", "=", "\"", "{{pushConfig.isBeauty}", "}\"", "\r\n    ", "muted", "=", "\"", "{{pushConfig.isMute}", "}\"", "\r\n    ", "background-mute", "=", "\"true\"", "\r\n    ", "debug", "=", "\"", "{{pushConfig.showLog}", "}\"", "\r\n    ", "bindstatechange", "=", "\"onPushStateChange\"", "\r\n    ", "bindnetstatus", "=", "\"onPushNetStateChange\"", ">", "\r\n    ", "<", "cover-view", " ", "class", "=", "'character'", " ", "style", "=", "'padding: 0 5px;'", ">", "{{isPublishing ? \"我(\" + publishStreamID + \")\": \"\"}", "}", "</", "cover-view", ">", "\r\n", "</", "live-pusher", ">", "\r\n", "请注意：", "SD、HD 和 FHD 主要用于直播类场景，比如赛事直播、在线教育、远程培训等等。SD、HD 和 FHD 分别对应三种默认的清晰度。该模式下，小程序会更加注重清晰度和观看的流畅性，不会过分强调低延迟，也不会为了延迟牺牲画质和流畅性", "RTC 则主要用于双向视频通话或多人视频通话场景，比如金融开会、在线客服、车险定损、培训会议 等等。该模式下，小程序会更加注重降低点到点的时延，也会优先保证声音的质量，在必要的时候会对画面清晰度和画面的流畅性进行一定的缩水", "3.3 服务端的选择", "由于自己搭 ", "rtmp", " （例如 ", "Nginx rtmp", " ）成本较高，技术实现难度大，考虑云服务商提供的视频直播服务产品，生成推流地址和播放地址，目前市面上主流的云直播产品有：腾讯云、阿里云、七牛云等。", "各平台均提供内容接入与分发和分布式实时视频处理技术，每个平台提供的功能大同小异但各有千秋，平均费用大概 20-30元/100G，100G流量可以满足100人同时在线直播4小时", "接下来选择腾讯云直播进行接入体验", "申请腾讯云账号，开通云直播权限，它会赠送20gb流量给你 超出需要自己花钱。开通流程请参考下面的文档： ", "https://cloud.tencent.com/document/product/454/12517", "域名管理，在这里面会看到两个域名 一个是推流域名 一个是播放域名，域名可以用自己的 （建议配置自己的域名，2019/2/26上线查看时发现赠送的播放域名已失效）。具体看下面的文档 ", "https://cloud.tencent.com/document/product/267/20381", "由于腾讯云不再赠送播放域名，所以需要租用或者使用自己的域名生成播放地址，自己的播放域名不能直接访问，需要完成CNAME配置", "最后，小程序直播组件API接入", "第一步： ", "<live-pusher>", " 推流（数据包实时上传）示例代码：", "使用 ", "<live-pusher>", " 发布流，这里使用的参数 ", "min-bitrate=\"200\"", " 最小码率 ", "max-bitrate=\"400\"", " 最大码率 ", "mode=\"RTC\"", " RTC模式，加入房间之后我们需要调用 ", "publish", " 返回一个 ", "rtmp", " 推流地址", "<", "live-pusher", "\r\n  ", "autopush", "\r\n  ", "min-bitrate", "=", "\"200\"", "\r\n  ", "max-bitrate", "=", "\"400\"", "\r\n  ", "mode", "=", "\"RTC\"", "\r\n  ", "url", "=", "\"", "{{publishPath}", "}\"", ">", "\r\n", "</", "live-pusher", ">", "\r\n", "先使用 ", "wx.createLivePusherContext", " 创建 ", "LivePusherContext", " ，再使用 setData 设置好 publishPath 之后发布", "// index.js", "\r\n\r\nPage({\r\n  ", "data", ": {\r\n    ", "publishPath", ": ", "undefined", ",\r\n  },\r\n  publish() {\r\n  ", "// joinRoom 之后调用", "\r\n  ", "// 创建 LivePusherContext", "\r\n  ", "const", " pushContext = wx.createLivePusherContext()\r\n  ", "const", " path = session.publish()\r\n  ", "this", ".setData(\r\n    { ", "publishPath", ": path },\r\n    () => {\r\n      pushContext.start({\r\n          ", "success", ": ", "()", " =>", " {\r\n            ", "console", ".log(", "'推流成功'", ")\r\n          },\r\n          ", "fail", ": ", "()", " =>", " {\r\n            ", "console", ".log(", "'推流开始失败'", ")\r\n          }\r\n        })\r\n    })\r\n  }\r\n})\r\n", "第二步： ", "<live-player>", " 播放（数据包实时下载）示例代码：", "使用 ", "<live-player>", " 订阅流，加入房间之后我们可以调用 ", "subscribe", " 返回一个 ", "rtmp", " 拉流地址。 下面我们使用了 ", "wx:for", " 遍历 ", "data.subscribeList", " 渲染一个订阅的列表", "<", "live-player", "\r\n  ", "autoplay", "\r\n  ", "wx:key", "=", "\"", "{{item.key}", "}\"", "\r\n  ", "wx:for", "=", "\"", "{{subscribeList}", "}\"", "\r\n  ", "min-cache", "=", "\"0.2\"", "\r\n  ", "max-cache", "=", "\"0.8\"", "\r\n  ", "src", "=", "\"", "{{item.url}", "}\"", "\r\n  ", "mode", "=", "\"RTC\"", ">", "\r\n", "</", "live-player", ">", " "]}
{"title": "微信小程序的socket.io即时通讯开发（基于E聊SDK） ", "author": "Rolan", "pub_time": "2020-6-15 00:44", "content": [" \n                     \n                    ", "1.背景：", "由于微信", "小程序", "需要开发轻量，跨平台，开发时间短等特点，许多公司将小程序作为了业务展示的第一个APP。E聊客户端核心SDK 通讯部分已适配了微信小程序平台，下面分享一下适配过程中的思路与方法。", "2.分析：", "微信小程序接入要求: 微信小程序主要支持https 与 wss 两种通讯方式，前者用于api 单次请求，后者用于长连接。 上线前，必须在小程序后台配置页 配置服务器域名地址(要求备案，不能是IP地址)才能请求后端服务器，否则请求被拦截 。", "E聊通讯方式: E聊同时使用了http连接和socket.io 连接，前者用于常用的api请求(比如:添加好友，发送消息); 后者用于实时通讯(比如:接受实时消息，接受系统通知)。", "结论: 在微信https 基础上实现api 请求; 在wss 基础上实现socket.io，实现实时通讯的功能。", "2.开发接入：", "2.1 新建一个\"云开发demo\", 在微信小程序开发者工具配置\"不校验合法域名\"", "这样就可以在小程序中暂时绕过备案域名的检测，使用ip或自己的域名进行调试了。", "2.2 下载E聊SDK 客户端核心代码，编译出小程序平台适用的echatim-sdk.js", "git clone http", "s:", "//gitee.", "com", "/dzqmeiji/echatim-client-", "ts", "-core.git\r\n", "cd", " echatim-client-", "ts", "-core\r\ngit checkout -", "b", " v1.", "01", " v1.", "01", " # checkout v1.", "01", " 版本\r\nyarn install\r\nyarn wxlib # 编译出echatim-sdk.js(若是windows平台:", "set", " platform=wx && webpack --", "mode", "=production --config ./build/webpack.lib.config.js)", "2.3 接入E聊核心SDK", "在云开发demo miniprogram 目录下新建utils 目录, 将上一步生成的echatim-sdk.js 放进utils 目录里，最终如下:", "在云开发demo miniprogram/page/index.js 文件下加入sdk配置相关代码, 并在onLoad中 初始化e聊sdk:", "const", " app = getApp()\r\n", "var", " sdk = ", "require", "(", "'../../utils/echatim-sdk.js'", ");\r\n\r\n", "function", " ", "initEasyIMSDKWithConfig", "(", ") ", "{\r\n  ", "const", " sdkConfig = {};\r\n  sdkConfig.host = ", "'api.echatim.cn'", ";\r\n  sdkConfig.httpPort = ", "58082", ";\r\n  sdkConfig.socketPort = ", "59092", ";\r\n  sdkConfig.key = ", "'TSDKTEST00001'", ";\r\n  sdkConfig.secret = ", "''", ";\r\n  sdkConfig.apiTransport = ", "'HTTP'", ";\r\n  sdkConfig.loginAuid = ", "'admin'", ";\r\n  sdkConfig.loginToken = ", "'admin'", ";\r\n  sdkConfig.fileServerConfig = {\r\n      ", "use", ": ", "'local'", ",\r\n      ", "client", ": ", "'plupload'", ",\r\n      ", "baseUrl", ": ", "'http://api.echatim.cn:58082'", ",\r\n      ", "version", ": ", "'v1'", ",\r\n  };\r\n  initEasyIMSDK(sdkConfig);\r\n}\r\n", "function", " ", "initEasyIMSDK", "(", "sdkConfig", ") ", "{\r\n  ", "if", " (sdk.im === ", "undefined", ") {\r\n      ", "console", ".error(", "\"Not found echatim sdk, please import echatim-sdk.js first.\"", ");\r\n      ", "return", ";\r\n  }\r\n  ", "var", " im = sdk.im;\r\n  im.init(sdkConfig, ", "function", " (", "sdk", ") ", "{\r\n      ", "if", " (sdk) {\r\n          ", "console", ".log(sdk);\r\n          ", "console", ".info(", "'echatIMSDK 成功连接, 可以使用 sdk.apis 请求数据了.'", ");\r\n      } ", "else", " {\r\n          ", "throw", " ", "Error", "(", "\"echatIMSDK 初始化失败\"", ");\r\n      }\r\n  });\r\n}\r\n\r\n\r\nPage({\r\n", "// ... 省略代码 ...", "\r\n  onLoad: ", "function", "(", ") ", "{\r\n    ", "console", ".log(sdk);\r\n    ", "// 初始化E聊SDK", "\r\n    initEasyIMSDKWithConfig();\r\n  }\r\n\r\n", "// ... 省略代码 ...", "\r\n})", "重跑小程序项目, 见到终端输出\"echatIMSDK 成功连接\"的文字表示e聊sdk 已成功建立连接.", "3.适配微信小程序的原理：", "由于e聊sdk 要求跨平台支持Web, 微信小程序， ReactNative 等平台， 故需要将平台相关的代码抽出来单独处理，根据不同的平台编译出不同的sdk 代码。", "具体请参考: ", "E聊SDK在TypeScript下的条件编译", "3.1 加入微信小程序平台的http访问连接.", "在源码HttpApi.ts httpFetch中，加入微信小程序的支持部分。", "private httpFetch(url:string, ", "request", ":any):", "Promise", "<ApiResponse<V>>{\r\n        ", "/*IFTRUE_WXAPP*/", "\r\n        ", "// @ts-ignore", "\r\n        ", "if", "(wx === ", "undefined", "){\r\n            ", "throw", " ", "new", " ", "Error", "(", "'wx handle not exist'", ");\r\n        }\r\n        ", "return", " ", "new", " ", "Promise", "<ApiResponse<V>>(", "function", " (", "resolve, reject", ") ", "{\r\n            ", "// @ts-ignore", "\r\n            wx.request({\r\n                ", "method", ": request.method,\r\n                ", "url", ": url, \r\n                ", "data", ": Beans.bean(request.body),\r\n                ", "header", ": request.headers,\r\n                success (res) {\r\n                    ", "// console.log(res.data)", "\r\n                    resolve(res.data);\r\n                },\r\n                fail(res){\r\n                    ", "// console.error(res.data)", "\r\n                    reject(res.data);\r\n                }\r\n            });\r\n        });\r\n        ", "/*FITRUE_WXAPP*/", "\r\n", "// ... 省略代码 ...", "\r\n}", "3.2 加入支持微信小程序平台的socket.io连接.", "在源码Socket.ts connect中，加入微信小程序的支持部分。", "/*IFTRUE_WXAPP*/", "\r\n        ", "const", " wxio = ", "require", "(", "'weapp.socket.io'", ");\r\n        ", "this", ".socket = wxio.connect(url+", "\"\"", ");\r\n        ", "/*FITRUE_WXAPP*/", "这里使用了一个支持微信小程序的socket.io 开源插件: ", "https://github.com/weapp-socketio/weapp.socket.io", "3.3 加入支持微信小程序平台的文件上传功能(1.01版本暂未实现业务功能)", "在源码FileServerClient.ts FileServerClientFactory中，加入微信小程序的支持部分(1.01版本暂未业务功能)。", "/*IFTRUE_WXAPP*/", "\r\n            ", "throw", " ", "new", " ", "Error", "(", "`not support wechat app platform`", ");\r\n", "/*FITRUE_WXAPP*/", "4.总结：", "微信小程序支持https, wss 两种连接方式, E聊SDK能适配小程序平台;", "E聊SDK 在设计之初已具有良好的跨平台支持。", "5.参考：", "微信小程序socket.io", "E聊SDK在TypeScript下的条件编译", " "]}
